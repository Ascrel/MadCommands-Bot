import discord
from discord.ext.commands import Bot
from discord.ext import commands
import os
import asyncio

Client = discord.Client()
bot = commands.Bot(command_prefix='-')
bot.remove_command("help")

@bot.event
async def on_ready():
    print("==================================")
    print(" ")
    print("MadCommands v2.3.0 build 1208")
    print(" ")
    print("Bot is ready")
    print(" ")
    print("==================================")
    await bot.change_presence(discord.Game("-cmd | Acsrel"))

@bot.command(pass_context=True)
async def help(ctx, cmd=None):
    if cmd == None:
        await ctx.send("```cmd\nType -help <topicname> to show more details about:\n\nediting: how to define and edit your custom commands\nusage: how to run your custom commands\ncommands: special commands to use in your scripts\nexpressions: how to write expressions and calculations\noperators: list of supported binary operatory\nfunctions: list of supported functions\nvariables: list of special pre-defined variables\nevents: list of supported event names\npermissions: permission nodes you can use\nlicense: license conditions for using this plugin\n```")
    elif cmd.lower() == "editing":
        await ctx.send("```cmd\nThese commands will let you define custom commands and their procedures:\n\n/cmd install [<command_name>]\n/cmd create <command_name> [<description> [ | <usage>]]\n/cmd modify <command_name> <new_name> [<description> [ | <usage>]]\n/cmd delete <command_name> [<start_line_number>[..<end_line_number>]]\n/cmd add <command_name> [asop|ascon] <command> [<parameter>] ...\n/cmd edit <command_name> <line_number> [asop|ascon] <command> [<parameter>] ...\n/cmd insert <command_name> <line_number> [asop|ascon] <command> [<parameter>] ...\n/cmd list [<command_name>] [<start_line_number>[..<end_line_number>]]\n/cmd enable <command_name>\n/cmd disable <command_name>\n/cmd register <command_name>\n/cmd unregister <command_name>\n/cmd trigger [<event_name> [<command_name>]]\n/cmd config [<option_name> [<new_value>]]\n/cmd run <command> [<parameter>] ...\n/cmd running [<command_id>]\n/cmd kill <command_id>\n\nType -help <command> to get detailed help for a specific command.\n```")
    elif cmd.lower() == "install":
        await ctx.send("```cmd\nThe /cmd install command can be used to install pre-defined command procedures from an external repository.\n\nTyping simply /cmd install with no extra parameters will list all available commands in the repository.\n\nUse /cmd install <command_name> to install specific command of your choice.\n\nBy default, madhon's repository is used. You can repoint the plugin to a different repository by modifying the install-source config option.\n\nEXAMPLES:\n/cmd install\n/cmd install countdown\n```")
    elif cmd.lower() == "create":
        await ctx.send("```cmd\nUse /cmd create <command_name> to create a new command procedure.\n\nIf you want your procedure to be registered as a regular command, you can also provide optional description and usage for the standard /help command:\n\n/cmd create <command_name> <description> | <usage>\n\nAfter the command is registered, users can use /help <command_name> to check the command's description and usage.\n\nWhether new commands are automatically enabled and/or registered when created can be controlled by modifying the enable-new-commands and register-new-commands config options.\n\nEXAMPLES:\n/cmd create hello\n/cmd create hello This command says hello | /hello\n```")
    elif cmd.lower() == "modify":
        await ctx.send("```cmd\nYou can use /cmd modify to rename an already defined custom command or to change its description and usage displayed by the /help command.\n\nTo just rename your command use /cmd modify <command_name> <new_name>\n\nTo modify rename your command AND modify its description, use:\n\n/cmd modify <command_name> <new_name> <new_description> | <new_usage>\n\nEXAMPLES:\n/cmd modify hello hi\n/cmd modify hello hello Say hello to online players\n/cmd modify hi hi Say hi to everyone | /hi\n```")
    elif cmd.lower() == "delete":
        await ctx.send("```cmd\nUse this command to delete either one or more lines from your custom command procedure or the whole procedure.\n\nTo delete a single line from your custom command procedure, use:\n/cmd delete <command_name> <line_number>\n\nTo delete multiple lines from your custom command procedure, use:\n/cmd delete <command_name> <start_line_number>..<end_line_number>\n\nTo delete whole custom command, use:\n/cmd delete <command_name>\n\nEXAMPLES:\n/cmd delete hello 2\n/cmd delete hello 11..25\n/cmd delete hello\n```")
    elif cmd.lower() == "add":
        await ctx.send("```cmd\nUse /cmd add to add a new command line to the end of your custom command procedure:\n\n/cmd add <command_name> [asop|ascon] <command> [<parameter>] ...\n\nNote that regular game commands need to be typed exactly as you would type them in the chat - including the leading forward slash character.\n\nIf you precede your command with ascon, this line will be executed from the console context. This has the advantage of bypassing any permission checking, but can only be used for commands that do work from the console context.\n\nIf you precede your command with asop, the player executing your procedure will be temporarily given Op permissions for the time of this line's execution, but the command itself will still be executed from the player's context.\n\nEXAMPLES:\n/cmd add makememember /me is now member\n/cmd add makememember ascon /setgroup %p% Member\n/cmd add makememember message %p% You are now member\n```")
    elif cmd.lower() == "edit":
        await ctx.send("```cmd\nYou can use the /cmd edit command to replace an existing line in your custom command procedure, or to create one with any line number of your choice:\n\n/cmd edit <command_name> <line_number> [asop|ascon] <command> [<parameter>] ...\n\nIf a line with the specified number already exists, it will be replaced with your new command. If the line does not exist, it will be added without modifying any other lines of the procedure.\n\nUsing a custom line number is very helpful when you want to jump to another part of your procedure using the goto command but don't know how many lines of code you will need to write between the two parts yet. Common practice used by BASIC programmers is to initially number all lines by the multiplies of 10, so that you can insert extra commands in between without having to renumber the following lines.\n\nType /cmd help add to learn about the ascon and asop options.\n\nEXAMPLES:\n/cmd edit hello 10 /say Nice to see you here\n/cmd edit hello 5 /say Hello everyone!\n/cmd edit hello 7 exit\n```")
    elif cmd.lower() == "insert":
        await ctx.send("```cmd\nUse /cmd insert when you need to insert an extra command line between already existing lines of your procedure and you have not skipped any line number for later use:\n\n/cmd insert <command_name> <line_number> [asop|ascon] <command> [<parameter>] ...\n\nThis command will increment all line numbers immediately following the line number you're inserting, until a skipped line number of end of procedure is found.\n\nNote that any existing goto commands will remain unchanged, so remember to verify they are still pointing to the right lines after doing the insert.\n\nType /cmd help add to learn about the ascon and asop options.\n\nEXAMPLES:\n/cmd insert hello 5 /spawn\n```")
    elif cmd.lower() == "list":
        await ctx.send("```cmd\nThis command lists existing custom command procedures or their commands.\n\nTo display a list of all defined custom command procedures, simply type /cmd list with no extra parameters.\n\nTo display all command lines of a specific custom command procedure, type /cmd list <command_name>.\n\nIf your procedure is very long and you want to display only portion of it, you can also specify the range of command line numbers to display:\n\n/cmd list <command_name> <start_line_number>..<end_line_number>\n\nEXAMPLES:\n/cmd list\n/cmd list countdown\n/cmd list copyblock 1..10\n```")
    elif cmd.lower() == "enable":
        await ctx.send("```cmd\nUse this command to enable a command procedure that has not been enabled yet (if you have automated enabling of new commands turned off) or that has been previously disabled.\n\n/cmd enable <command_name>\n\nYou can control whether newly created commands are automatically enabled by modifying the enable-new-commands config option.\n```")
    elif cmd.lower() == "disable":
        await ctx.send("```cmd\nUse this command to disable a command procedure. When disabled, the command procedure does exist and can be edited, but cannot be executed.\n\n/cmd disable <command_name>\n\nYou can control whether newly created commands are automatically enabled by modifying the enable-new-commands config option.\n```")
    elif cmd.lower() == "register":
        await ctx.send("```cmd\nUse this command to register a custom command to be recognized as a proper /command. When registered, your command will be recognized by the game, as well as by the /help command.\n\n/cmd register <command_name>\n\nIf you register a custom command with the same name as an already existing regular command, your procedure will be used to override the standard functionality. You can still call the original command from within the procedure.\n\nNote that while newly registered commands can be used even from within the console, overriding existing commands only works in the player context.\n\nYou can control whether newly created commands are automatically registered by modifying the register-new-commands config option.\n```")
    elif cmd.lower() == "unregister":
        await ctx.send("```cmd\nUse this command to stop your command procedure from being automatically registered as a proper command when starting the server. Since PocketMine does not currently support unregistering a single command, you have to restart your server for the command to finally stop working.\n\n/cmd unregister <command_name>\n\nYou can control whether newly created commands are automatically registered by modifying the register-new-commands config option.\n```")
    elif cmd.lower() == "trigger":
        await ctx.send("```cmd\nMadCommands is able to trigger your custom command procedures when specific things happen in the game.\n\nTo make your command procedure automatically run whenever the desired event happens, use the following command:\n\n/cmd trigger <event_name> [to|from <area>] <command_name>\n\nTo unassign your command procedure from the event, simply use the same command without specifying command name:\n\n/cmd trigger <event_name> [to|from <area>]\n\nFor the move event, area can be specified either as a named area defined by LeetProtector or as a combination of level name and coordinates in one of the following forms:\n\n<level> <x1> <z1> <x2> <z2>\n<level> <x1> <y1> <z1> <x2> <y2> <z2>\n<level>[<x1>,<y1>,<z1>|<x2>,<y2>,<z2>]\n\nTo list all current triggers, simply type /cmd trigger\n\nWhen an event triggers your command procedure it passes some event-specific data to it as parameters. To learn more about individual events supported by this version of MadCommands, type /cmd help events.\n\nEXAMPLES:\n/cmd trigger\n/cmd trigger login welcome\n/cmd trigger death\n/cmd trigger move from world 0 0 255 255 leftspawn\n```")
    elif cmd.lower() == "config":
        await ctx.send("```cmd\nThe MadCommands plugin can be configured using the config.yml file placed in the plugin's folder. However, you can also check and modify some of the config options without having to restart the server and without even having access to the config file.\n\nTo check the current config and see what config options you have access to from within the game, simply type /cmd config with no extra parameters.\n\nTo check the current value of a specific config option, type:\n/cmd config <option_name>\n\nTo modify the config option, use the following syntax:\n/cmd config <option_name> <new_value>\n\nEXAMPLES:\n/cmd config\n/cmd config user-configurable-options\n/cmd config register-new-commands false\n```")
    elif cmd.lower() == "run":
        await ctx.send("```cmd\nUse this command to run a custom command you have enabled but not registered.\n\n/cmd run <command> [<parameter>]\n```")
    elif cmd.lower() == "running":
        await ctx.send("```cmd\nUse this command to get information about commands that are currently running.\n\nTo get a list of all running commands type:\n\n/cmd running\n\nTo get detailed information about specific running command, use:/cmd running <command_id>\n\nNote that you can only get information about paused commands and commands running in async worker this way because only one command can be running in the server thread at a moment, including the commund listing all running commands.\n```")
    elif cmd.lower() == "kill":
        await ctx.send("```cmd\nThis command lets you ask a running command to exit.\n\n/cmd kill <command_id>|all\n\nThis can become handy when you accidentally (or intentionally) create an endless loop and override the command execution timeout by using sleep or switching between sync and sync modes often enough.\n```")
    elif cmd.lower() == "usage":
        await ctx.send("```cmd\nUse your custom command the same way as you would use any other command:\n\n/<command_name> [<parameter>] ...\n\nor use /cmd run to run it from context where custom commands don't work:\n\n/cmd run <command_name> [<parameter>] ...\n```")
    elif cmd.lower() == "commands":
        await ctx.send("```cmd\nThese commands can be used only as part of your custom command procedures:\n\ngoto <line_number>\nexit\n\nsleep <seconds>\nschedule <seconds> <command> [<parameter>] ...\nasync\nsync\n\nif <expression> then <command> [<parameter>] ...\n\nlet %<variable_name>% = <expression>\nlet %<variable_name>%[] = <expression>\nlet %<variable_name>%[<number>] = <expression>\nlet %<variable_name>%[""<text>""] = <expression>\nlet %<variable_name>%[%<variable_name>%] = <expression>\n\nsave %<variable_name>%\nload %<variable_name>%\n\nmessage <player_name>|<players_array> <message>\ntip <player_name>|<players_array> <message>\naction <player_name>|<players_array> <message>\npopup <player_name>|<players_array> <multi_line_message>\ntitle <player_name>|<players_array> <two_line_message>\n\ndrop <level> <x> <y> <z> <item_id>[:<meta>]\nblock <level> <x> <y> <z> <block_id>[:<meta>] [<x2> <y2> <z2>]\nstore <level> <x> <y> <z> <items_array>\nwrite <level> <x> <y> <z> <sign_text>\nsound <level> <x> <y> <z> <sound_id> [<modifier> [<entity_type> [<players>]]]\ncarry <player_name> <items_array>\nwear <player_name> <items_array>\nhold <player_name> <item_id>[:<meta>]\nmove <player_name> <level> <x> <y> <z> [<yaw> [<pitch>]]\ntreat <player_name> <health> [<saturation> [<food> [<exhaustion>]]]\nxp <player_name> <xp_level> <xp_progress>\nboss <action> <boss> [<player(s)>] [<health>] [<title>]\n\nprotect <area_name> <level> <x1> <y1> <z1> <x2> <y2> <z2> [<flags>]\n\ncancel\n\n# <comments>\n\nType /cmd help <command> to get detailed help for a specific command.\nType /cmd help comments to learn about using comments.\n```")
    elif cmd.lower() == "goto":
        await ctx.send("```cmd\nUse this command to jump to a specific command line:\n\ngoto <line_number>\n\nYou can use this command to create loops or to skip certain lines depending on specific conditions. Make sure to use this command in combination with if-then to avoid endless loops.\n\nEXAMPLE:\n1 do something\n2 if condition then exit\n3 goto 1\n```")
    elif cmd.lower() == "exit":
        await ctx.send("```cmd\nUse the exit command whenever you want to exit the command procedure immediately:\n\nexit\n\nThis is useful for exiting loops or to stop execution of unfinished command procedure you're debugging.\n\nEXAMPLE:\n1 do something\n2 if condition then exit\n3 goto 1\n```")
    elif cmd.lower() == "sleep":
        await ctx.send("```cmd\nUse the sleep command to wait for certain amount of time before performind the following commands:\n\nsleep <seconds>\n\nNote that when used in the main thread, this command schedules a delayed task to execute the remaining commands. When the scheduled task is started, the command procedure timeout is reset as if the procedure was just starting, so you can effectively use the sleep command to keep a long procedure running without timing out and without blocking the server for too long.\n\nUsing sleep in async mode causes the command procedure to simply wait, and timeout defined in the plugin configuration still applies.\n\nCheck the proc-max-time and proc-max-time-async config options to find out what timeouts are applies in sync and async execution modes respectively.\n\nEXAMPLE:\n1 sleep 600\n2 message %p% Ten minues elapsed, the eggs must be finished now\n```")
    elif cmd.lower() == "schedule":
        await ctx.send("```cmd\nUse this command to schedule another command procedure to be executed later:\n\nschedule <seconds> <command_name> [<parameter>] ...\n\nThis command works almost like /cmd run except for that it does not run the procedure immediately but instead schedules it to run later.\n\nThe specified command procedure needs to be enabled but does not have to be registered as command.\n\nYou cannot schedule any commands using this command, only command procedures created by MadCommands. You can, however, schedule the same procedure, turning it to a regularly repeated task.\n\nEXAMPLE:\n1 /say ding-dong\n2 schedule 3600 chime\n```")
    elif cmd.lower() == "async":
        await ctx.send("```cmd\nThis command switches the currently running command procedure to the asynchronous mode.\n\nasync\n\nIn asynchronous mode, the following commands are executed in an asynchronous task, not blocking the main server thread.\n\nUse this to perform actions that take long time, such as complex calculations, and do not need to interact with the game, to avoid unnecessary lags.\n\nNote that game commands cannot be used in asynchronous mode because accessing the main thread's data structures from an async task would cause the server to crash.\n\nUse the sync command to switch back to synchronous execution mode.\n\nEXAMPLE:\n1 let %inventory% = playeinventory(%p%)\n2 async\n3-19 examine and adjust player's inventory\n20 sync\n21 carry %p% %inventory%\n```")
    elif cmd.lower() == "sync":
        await ctx.send("```cmd\nThis command switched the currently running command procedure back to synchronous execution mode after it was switched to asynchronous mode with the async command:\n\nsync\n\nType /cmd help async to learn more about asynchronous execution.\n```")
    elif cmd.lower() == "if":
        await ctx.send("```cmd\nThe if-then command lets you execute command only if certain condition is met. The syntax loks like this:\n\nif <expression> then <command> [<parameter>] ...\n\nWhat it does is that it first evaluates the expression entered between the word if and the word then. If the result of the expression is true or a valid non-zero number, or a non-empty string, then the command entered after the word then is executed. If the result of the expression is false or zero, or an empty string, then the rest of the command is simply ignored.\n\nThis is the most important command to be able to implement any kind of logic and decision-making in your command procedures, so necessary to make complex features, such as minigames.\n\nEXAMPLES:\n1 ascon if %p% = 'madhon' then /op %p%\n2 if %y% > 127 then message %p% You're flying too high\n3 load %past_participants%\n3 if %p% notin %past_participants% then goto 10\n4 message %p% You have already played this game\n5 exit\n```")
    elif cmd.lower() == "let":
        await ctx.send('```cmd\nUse the let command to assign value to a variable.\n\nMadCommands requires every variable name to be enclosed by the percent (%) signs, i.e. %x% or %mylongvariablename%. This limitation is to make the plugin slightly easier to develop and faster to parse your commands. It makes it also easy to use variables in game commands and have them replaced with their values when executing the commands.\n\nTo simply assign result of an expression to a variable, use:\n\nlet %<variable_name>% = <expression>\n\nMadCommands also supports arrays (one variable containing multiple values), both sequential and associative. If you want to add a new value to the end of an array, use empty square brackets:\n\nlet %<variable_name>%[] = <expression>\n\nTo assign value to a specific index of an array, include the desired index in the square brackets. Index can be either number or string:\n\nlet %<variable_name>%[<number>] = <expression>\n\nlet %<variable_name>%["<text>"] = <expression>\n\nYou can also use another variable as an index. In that case the value of the variable is used as index:\n\nlet %<variable_name>%[%<variable_name>%] = <expression>\n\nTo delete variable, simply assign nothing to it:\n\nlet %<variable_name% =\nlet %<variable_name>%[<number>] =\nlet %<variable_name>%["<text>"] =\n\nYou can use any combination of letters, numbers, underscores, and dashes as variable name, as long as it starts with a letter.\n\nYou cannot, however, use the let command to assign values to any of the pre-defined variables, such as %p%, %x%, or %time%. Type /cmd help variables to learn about pre-defined variables.\n\nYou can use any variable as part of any commands parameters. Each variable will be replaced with its value when executing the command. You cannot, however, directly reference array elements this way. To use an array element in a command, you first have to assign it to a dedicated variable.\n\n\n```')
        await ctx.send('```cmd\nThe let command can be implicit. You can simply omit it and just begin the command with the variable name.\n\nEXAMPLES:\n1 let %a% = -123\n2 let %b% = "bbb"\n3 let %c% = %a%\n4 let %d%[3] = "three"\n5 let %d%[5] = "five"\n6 let %d%[] = "six"\n7 let %e%["a"] = %a%\n8 let %e%["d"] = %d%\n9 %e%[%b%] = %b%\n```')
    elif cmd.lower() == "save":
        await ctx.send("```cmd\nVariables normally exist only as long as your procedure is running. To keep value of any variable for later user, you can use the save command:\n\nsave %<variable_name>%\n\nSaved variable survives even server restarts, so is very useful for storing things like minigame leaderboards or per-player settings. Use the load command to reload previously saved variable.\n\nYou can use the save command from the async execution mode but be careful not to try to save the same variable from two places at the same time. It is generally safer to only save variables in the synchronous mode.\n\nEXAMPLE:\n1 load %members%\n2 if %p% notin %members% then let %members%[] = %p%\n3 save %members%\n```")
    elif cmd.lower() == "load":
        await ctx.send("```cmd\nUse the load command to reload any variable previously saved using the save command:\n\nload %<variable_name>%\n\nEXAMPLE:\n1 load %members%\n2 if %p% notin %members% then let %members%[] = %p%\n3 save %members%\n```")
    elif cmd.lower() == "message":
        await ctx.send('```cmd\nThe message command displays message to a player or list of players. The message appears in the chat just like any other message.\n\nTo display message to a single player, provide the players name as first parameter and the message as second parameter:\n\nmessage <player_name> <message>\n\nYou can provide a valid expression as a message. Otwherwise everything after the second space is considered the message.\n\nTo send a message to multiple players, provide a valid expression resulting in an array as the first parameter:\n\nmessage <players_array> <message>\n\nThe message will then get broadcasted to all players listed in the array.\n\nEXAMPLES:\n1 message %p% This is simple message\n2 message %p% "This is expression message"\n3 message %p% %args%[1+]\n4 message onlineplayers() This is simple broadcast\n5 message onlineplayers() "This is\\nmulti-line\\nbroadcast"\n```')
    elif cmd.lower() == "tip":
        await ctx.send('```cmd\nThe tip command works exactly like the message command, except for that the message is displayed in the bottom third of the players screen and fades away in a short moment.\n\ntip <player_name>|<players_array> <message>\n\nThe only difference between tip and action is that tip is displayed as text with a shadow, while action does not have any shadow.\n\nEXAMPLES:\n1 tip %p% This is simple tip\n2 sleep 1\n3 tip %p% "This is expression tip"\n4 sleep 1\n5 tip %p% %args%[1+]\n6 sleep 1\n7 tip onlineplayers() This is simple tip broadcast\n```')
    elif cmd.lower() == "action":
        await ctx.send('```cmd\nThe action command works exactly like the message command, except for that the message is displayed in the bottom third of the players screen and fades away in a short moment.\n\naction <player_name>|<players_array> <message>\n\nThe only difference between tip and action is that tip is displayed as text with a shadow, while action does not have any shadow.\n\nEXAMPLES:\n1 action %p% This is simple action\n2 sleep 1\n3 action %p% "This is expression action"\n4 sleep 1\n5 action %p% %args%[1+]\n6 sleep 1\n7 action onlineplayers() This is simple action broadcast\n```')
    elif cmd.lower() == "popup":
        await ctx.send('```cmd\nThe popup command works exactly like the message command, except for that the message is displayed right above the inventory hotbar rather than in the chat, and fades away in a short moment.\n\npopup <player_name>|<players_array> <two_line_message>\n\nUnlike the tip and action commands, popup can display multiple lines of text. In order to do that you need to supply the message as an expression, evaluating to a string with two or more lines of text. You can use the C-style escape sequence "\n" to include line break in a string.\n\nEXAMPLES:\n1 popup %p% This is simple popup\n2 sleep 1\n3 popup %p% "This is expression popup"\n4 sleep 1\n5 popup %p% %args%[1+]\n6 sleep 1\n7 popup onlineplayers() This is simple popup broadcast\n8 sleep 1\n9 popup %p% "This is\\ntwo-line popup"\n```')
    elif cmd.lower() == "title":
        await ctx.send('```cmd\nThe title command displays a big text title in the center of the players screen. It can also display a smaller subtitle beneath the main title if you supply a two-line message as a parameter.\n\ntitle <player_name>|<players_array> <two_line_message>\n\nThe title command works exactly like the message command in terms of specifying target players and message to display.\n\nIn order to do display also a subtitle you need to supply the message as an expression, evaluating to a string with two lines of text. You can use the C-style escape sequence "\\n" to include line break in a string.\n\nEXAMPLES:\n1 title %p% This is simple title\n2 sleep 1\n3 title %p% "This is expression title"\n4 sleep 1\n5 title %p% %args%[1+]\n6 sleep 1\n7 title onlineplayers() This is simple title broadcast\n8 sleep 1\n9 title %p% "This is title\\nThis is subtitle"\n```')
    elif cmd.lower() == "drop":
        await ctx.send('```cmd\nUse the drop command to drop an item at certain position of the game world/map, just like if it was dropped by a player or destroyed chest. You need to specify the level name and coordinates of the position where the dropped item is supposed to spawn:\n\ndrop <level> <x> <y> <z> <item_id>[:<meta>]\n\nAny player will then be able to collect the item, until it is automatically despawned.\n\nEXAMPLES:\n1 drop world 81 71 47 diamond_axe\n2 let %items% = array("diamond_sword", "gold_sword", "stone_sword", "wooden_sword")\n3 let %rnd% = random(0, 3)\n4 let %randomitem% = %items%[%rnd%]\n5 drop world 81 81 47 %randomitem%\n```')
    elif cmd.lower() == "block":
        await ctx.send('```cmd\nYou can use the block command to change a single block in the game world/map to anything you want. You need to specify the level name and coordinates of the block you want to change, and then the block id and optional metadata:\n\nblock <level> <x> <y> <z> <block_id>[:<meta>]\n\nIf you are setting a two-block item, such as bed ir double-chest (currently the only kinds of blocks supported this way), you have to specify coordinates of the second block as well:\n\nblock <level> <x> <y> <z> <block_id>[:<meta>] <x2> <y2> <z2>\nYou can specify the block by its numeric ID (i.e. 1 for stone), or by its name defined by PocketMine (i.e. "stone").\n\nWARNING: Although you can set multiple blocks in a loop, this command is not intended for automated building or filling of large areas, because every single block change produces update to be sent to all players in visible distance just like if a player in creative mode placed the block there. Setting too many blocks by a single procedure might cause significant lags. However, you can efficiently use this for resetting minigame elements, opening or closing hidden doors, etc.\n\nEXAMPLES:\n1 block world 81 71 47 stone2 block world 82 71 47 1:1\n3 block world 83 71 47 bed:3\n4 block world 84 71 47 26:11\n5 block world 86 71 47 bed 85 71 47\n```')
    elif cmd.lower() == "store":
        await ctx.send('```cmd\nUse the store command to store items in a blocks inventory:\n\nstore <level> <x> <y> <z> <items_array>\n\nCurrently only chests, trapped chests, and item frames are supported.\n\nFor item frames, the supplied items array is supposed to contain only one item. If you specify the item as an array also containing the "ItemRotation" node, you can have the item in the item frame rotated as desired.\n\nThe easiest way to prepare an array of items for use with the store command is to get it from another block of the same kind using the blockcontents function.\n\nNote: The store and write commands are internally the same, so you can use them interchangebly. This makes it easier to copy block including its contents regardless of whether it is a sign, chest, or item frame.\n\nEXAMPLE:\n0 # This works if there is a chest at 77,71,47\n1 let %items% = blockcontents("world", 77, 71, 47)\n2 block world 81 71 47 chest\n3 store world 81 71 47 %items%\n```')
    elif cmd.lower() == "write":
        await ctx.send('```cmd\nUse the write command to modify sign text:\n\nwrite <level> <x> <y> <z> <sign_text>\n\nThe block at the specified coordinates must be a sign.\n\n<sign_text> must be a valid expression resulting in either a text string with up to four lines of text, or an array of text strings. You can use the C-style escape sequence "\\n" to include line break in a string literal.\n\nNote: The store and write commands are internally the same, so you can use them interchangibly. This makes it easier to copy block including its contents regardless of whether it is a sign, chest, or item frame.\n\nEXAMPLE:\n1 block world 81 71 47 sign\n2 write world 81 71 47 "line 1\\nline 2\\nline 3\\nline 4"\n3 block world 82 71 47 sign\n4 write world 82 71 47 array("line 1", "line 2", "line 3", "line 4")\n```')
    elif cmd.lower() == "sound":
        await ctx.send('```cmd\nProduce game sound at specified position, hearable either by all nearby players, or by specified players:\n\nsound <level> <x> <y> <z> <sound_id> [<modifier> [<entity_type> [<players>]]]\n\nThe sound will be played like if it was caused at the specified place.\n\n<sound_id> can be either numeric sound ID or sound name. Valid numeric IDs are between 0 and 254 and between 1000 and 1063.\n\nSome sounds can have different variants or volume levels. You can select variant by providing numeric <modifier>. If you do not provide it, default sound will be produced. For note sound the modifier specifies tone. For some sounds, such as levelup very high values (over 100000000) need to be provided to make the sound hearable.\n\nSome useful sounds:\nambient, ambient_baby, ambient_in_water, death, hurt, eat, explode, fire, ignite, portal, portal_travel, levelup, power_on, power_off, note, armor_equip_elytra, glass, potion_brewed, camera_take_picture, door\n\nSome sounds, such as ambient or death need <entity_type> to be specified. You can provide either numeric entity ID, or entity name, such as player, creeper, or zombie. Valid entity IDs are, at the time of writing this, from 10 to 113.\n\nSome useful entities:\nplayer, creeper, zombie, spider, villager, enderman, shulker, ghast, ender_dragon\nIf you provide also name of one or more <players>, the sound will be heared only by those players. Otherwise all players close enough to the specified position will hear it.\n\nEXAMPLES:\n1 sound world 84 71 45 note 2\n2 sound world 84 71 45 ambient 0 zombie\n3 sound world 84 71 45 1003\n4 sound world 84 71 45 levelup 100663296 madhon\n```')
    elif cmd.lower() == "carry":
        await ctx.send('```cmd\nThe carry command sets players inventory, making him carry the items you have specified:\n\ncarry <player_name> <items_array>\n\nThe easiest way to prepare an array of items for use with the carry command is to get it from a player using the playerinventory function.\n\nEXAMPLE:\n1 let %items% = playerinventory("player1")\n2 carry player2 %items%\n```')
    elif cmd.lower() == "wear":
        await ctx.send('```cmd\nThe wear command sets players armor, making him wear the clothes you have specified:\n\nwear <player_name> <items_array>\n\nThe easiest way to prepare an array of items for use with the wear command is to get it from a player using the playerarmor function.\n\nEXAMPLE:\n1 let %items% = playerarmor("player1")\n2 wear player2 %items%\n```')
    elif cmd.lower() == "hold":
        await ctx.send("```cmd\nThe hold command sets item in player's hand, making him hold the item you have specified:\n\nhold <player_name> <item_id>[:<meta>]\n\nIf the specified item is already in the player's hotbar, the existing hotbar slot is selected. If the item is not in the player's hotbar but there is an empty slot in the hotbar, the empty slot is selected and the item is put into it. If there's no empty slot in the player's hotbar, the currently selected hotbar slot's contents is replaced by the item.\n```")
    elif cmd.lower() == "move-command":
        await ctx.send("```cmd\nThe move command moves (teleports) player to the specified world and position:\n\nmove <player_name> <level> <x> <y> <z> [<yaw> [<pitch>]]\n\nThis commands is able to set also player's yaw (horizontal direction he's looking in) and pitch (vertical direction).\n```")
    elif cmd.lower() == "treat":
        await ctx.send("```cmd\nThe treat command adjusts player's health and hunger condition:\n\ntreat <player_name> <health> [<saturation> [<food> [<exhaustion>]]]\n\nWith this command, you can directly set (reset) player's:\n\n- health (in the range from 0 to 20)\n- saturation (in the range from 0 to 20)\n- food (in the range from 0 to 20 - more food means less hungry)\n- exhaustion (in the range from 0 to 5)\n\nOnly health is mandatory parameter, remaining parameters are optional.\n\nEXAMPLES:\ntreat madhon 20\ntreat herobrine 1 0 1 5\n```")
    elif cmd.lower() == "xp":
        await ctx.send("```cmd\nThe xp command sets player's Xp level and progress:\n\nmove <player_name> <xp_level> <xp_progress>\n\nXp level can be set to any integer value between 0 and 24791, Xp progress can be set to anything between 0 and 1. For example, Xp progress of 0.3 stands for 30% experience progress at the current level.\n```")
    elif cmd.lower() == "boss":
        await ctx.send("```cmd\nThe boss command manages bossbars displayed to one or more players:\n\nboss <action> <boss> [<player(s)>] [<health>] [<title>]\n\nParameters to use depend on the specified action:\n\nboss create <boss> creates new boss entity no paired with a player\nboss delete <boss> deletes previously defined boss\nboss show <boss> <player(s)> shows the boss to specified player(s)\nboss hide <boss> [<player(s)>] hides the boss from player(s)\nboss health <boss> <health> sets the boss health (range 0-1)\nboss title <boss> <title> changes the boss title\n\nUsing boss show <playername> without previously creating the boss using boss create will link the bossbar to an existing player entity. Health value of the bossbar is, however, not updated automatically to let you decide what value it will represent.\n\nInitial health and title can be supplied as additional parameters for the boss show command.\n```")
    elif cmd.lower() == "cancel":
        await ctx.send("```cmd\nIn a command procedure started by a cancellable event trigger the cancel command will mark the originating event to be cancelled. In rare cases, cancellation can still be overridden by another plugin.\n\nThe cancel command is used simply alone, without any parameters:\n\ncancel\n\nType cmd help events to learn what events are supported and which ones can be cancelled.\n```")
    elif cmd.lower() == "#":
        await ctx.send("```cmd\nIf you want to add comments to your procedures to make them easier to understand, simply add lines beginning with the hash (#) character:\n\n# <comments>\n\nAny line beginning with the hash is simply ignored when executing the procedure, so the execution continues at the following line.\n```")
    elif cmd.lower() == "comments":
        await ctx.send("```cmd\nIf you want to add comments to your procedures to make them easier to understand, simply add lines beginning with the hash (#) character:\n\n# <comments>\n\nAny line beginning with the hash is simply ignored when executing the procedure, so the execution continues at the following line.\n```")
    elif cmd.lower() == "expressions":
        await ctx.send('```cmd\nSimple expressions:\n\n<number>\n"<text>"\n%<variable_name>%\n%<variable_name>%[<number>]\n%<variable_name>%[<number>+]\n%<variable_name>%["<text>"]\n%<variable_name>%[%<variable_name>%]\n\nComplex expressions:\n\n<simple_expression> [<operator> <expression>]\n(<expression>) [<operator> <expression>]\n<function_name>(<simple_expression>[, <simple_expression>]...)\n\nNote: When multiple operators are used without parentheses, they are not guaranteed to be evaluated in any particular order. C-style escape sequences, such as \\n, can be used in string literals.\n```')
    elif cmd.lower() == "operators":
        await ctx.send("```cmd\nYou can use the following binary operators in complex expressions:\n\n= - results in true if both sides are equal\n!= - results in true if each side is different\n> - results in true if left side is greater than right side\n>= - results in true if left side is greater or equal to right side\n< - results in true if left side is lower than right side\n<= - results in true if left side is lower or equal to right side\n+ - add two numbers/strings/arrays\n- - subtract second number/string/array from first one\n/ - divide first number by second number\n* - multiply two numbers\nand - true if both sides are true\nor - true if at least one of the sides is true\nin - true if value on the left exists in array/string on the right\nnotin - true if value on the left doesn't exist in array/string on the right\n```")
    elif cmd.lower() == "functions":
        await ctx.send("```cmd\nThe following functions are currently supported by MadCommands:\n\ngeturl(<url>) loads web url and returns its contents\nurlencode(<array>|<string>) encodes data to be used in url\ndejson(<string>) decodes JSON data to an array\nsplit(<string>, <delimiter>) converts string to an array\njoin(<array>, <delimiter>) converts array to a string\nsize(<array>|<string>) returns array elements count or string length\narray(<value>[, <value>] ...) builds a flat array from supplied parameters\nvarset(<variable>) returns true if <variable> exists\nrandom(<min>, <max>) returns random integer number in the <min>..<max> range\nint(<number>) returns integer part of number by cutting off the fractional part\n\nlowercase(<string>) converts string to lowercase letters\nuppercase(<string>) converts string to uppercase letters\nsubstring(<string>, <start>, <length>) extracts part of a text string\nposition(<array>|<string>, <substring>) returns position of substring in array or string\nreplace(<array>|<string>, <original>, <replacement>) replaces all occurrences of <original> in array or string with <replacement>\n\nonlineplayers([<filter>]) returns array of online player names\nplayerstatus(<playername>) returns array of information about player\nplayerarmor(<playername>) returns array of armor currently worn by player\nplayerinventory(<playername>) returns array of player's survival inventory\nplayerhand(<playername>) returns item held by the player in hand\nplayerbalance(<playername>) returns economy money balance of the player\nplayergroup(<playername>) returns PurePerms group/rank of the player\n\nblockinfo(<level>, <x>, <y>, <z>) returns array of information about world block\nblockcontents(<level>, <x>, <y>, <z>) returns contents of block, such as chest or sign\n```")
        await ctx.send("```cmd\nareaname(<level>, <x>, <y>, <z>) returns name of protected area for position\nareaname(<playername>) returns name of protected area player is in\nareainfo(<areaname>[, <playername>]) returns information about protected area\n\ndialog(<player>, <form_data>) shows dialog to player and returns response\n\nType /cmd help <function> to get detailed help for a specific function.\n```")
    elif cmd.lower() == "geturl":
        await ctx.send('```cmd\ngeturl(<url>) loads web url and returns its contents as string\n\nIf you know something about web APIs you know how powerful this function can be. if you dont check out the following online resources:\n\nUseful article: Web APIs for non-programmers:\nhttps://schoolofdata.org/2013/11/18/web-apis-for-non-programmers/\n\nGreat testing environment: JSONPlaceholder\nhttps://jsonplaceholder.typicode.com\n\nThe programmableweb.com website has a great directory of web APIs you could utilize. Or simply create your own on your website:\nhttps://www.programmableweb.com/category/all/apis\n\nIn order to avoid lag as much as possible, using the geturl function automatically temporarily switches your procedure execution to async mode if you try to use it in the synchronous mode. It is however still a good idea to ensure that you only use it for web APIs which return their results very fast.\n\nTo avoid waiting for a response forever, MadCommands has two configurable timeout options - geturl-max-connect-time and geturl-max-transfer-time. Type /cmd help config to learn about changing configurable options.\n\nSee also the urlencode and dejson functions as they are very useful when using geturl.\n\nEXAMPLES:\n1 let %myip% = geturl("https://api.ipify.org")\n2 let %users% = dejson(geturl("https://jsonplaceholder.typicode.com/users"))\n```')
    elif cmd.lower() == "variables":
        await ctx.send("```cmd\nIn addition to defining your own variables, you can use the following pre-defined variables in your commands:\n\n%p% Name of the player running the command\n%x% Player's x coordinate\n%y% Player's y coordinate\n%z% Player's z coordinate\n%yaw% Player's yaw (horizontal look direction)\n%pitch% Player's pitch (vertical look direction)\n%level% Player's level\n%gm% Player's gamemode\n%health% Player's health (0-20)\n%time% Current time in seconds from 16 August 2011 00:00:00\n%args% Array holding all parameters, while parameter 0 being the command itself\n%args%[n] N-th parameter of the command\n%args%[n+] All remaining parameters starting with N-th parameter\n%true% Bollean true\n%false% Bollean false\n```")
    elif cmd.lower() == "events":
        await ctx.send("```cmd\nThe following events can be set to trigger custom MadCommands procedure.\nProcedure does not have to be registered as command.\nWhen event triggers your procedure it will pass key information about the event to the\nprocedure as parameters.\nSome events can be cancelled using the cancel command if it is used soon enough.\n\nstartup triggers when the server finishes starting up\nshutdown triggers when the server is shutting down (or the plugin is disabled)\nlogin triggers when player joins the server\nleave triggers when player leaves the server\nspawn triggers when player is spawned or respawned\nbed triggers when player enters or leaves a bed (entering bed can be cancelled)\ngm triggers when player switches gamemode (can be cancelled)\neat triggers when player eats food (can be cancelled)\nchat triggers when player writes message in chat (can be cancelled)\ndamage triggers when player or mob gets damage (can be cancelled)\ndeath triggers when player dies\ncheat triggers when player tries to cheat (can be cancelled)\nplace triggers when player places a block (can be cancelled)\nbreak triggers when player breaks a block (can be cancelled)\ntouch triggers when player touches a block (can be cancelled)\nappear triggers when a new entity appears\ndisappear triggers when an entity disappears\nhit triggers when projectile hits a block or an entity\nmove triggers when player moves to or from specified area\n\nType /cmd help <event> to get detailed help for a specific event.\n```")
    elif cmd.lower() == "startup":
        await ctx.send('```cmd\nstartup triggers when the server finishes starting up\n\nThe command procedure you assign to the startup event will not be passed any parameters except for the event name:\n\n%args%[1] event name as string ("startup")\n```')
    elif cmd.lower() == "shutdown":
        await ctx.send('```cmd\nshutdown triggers when the server is shutting down or the plugin is disabled\n\nThe command procedure you assign to the startup event will not be passed any parameters except for the event name:\n\n%args%[1] event name as string ("shutdown")\n\nKeep in mind you should limit actions you perform in this procedure to an absolute minimum and finish promptly. Asynchronous and scheduled commands are likely to fail.\n```')
    elif cmd.lower() == "login":
        await ctx.send('```cmd\nlogin triggers when player joins the server\n\nThe command procedure you assign to the login event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("login")\n%args%[2] name of the player joining\n```')
    elif cmd.lower() == "leave":
        await ctx.send('```cmd\nleave triggers when player leaves the server\n\nThe command procedure you assign to the leave event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("leave")\n%args%[2] name of the player leaving\n\nYou cannot cancel this event.\n```')
    elif cmd.lower() == "spawn":
        await ctx.send('```cmd\nspawn triggers when player is spawned or respawned\n\nThe command procedure you assign to the spawn event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("spawn")\n%args%[2] name of the spawned player\n%args%[3] name of the level (world) the player has spawned in\n%args%[4] the X coordinate of the spawn point\n%args%[5] the Y coordinate of the spawn point\n%args%[6] the Z coordinate of the spawn point\n\nYou cannot cancel this event.\n```')
    elif cmd.lower() == "bed":
        await ctx.send('```cmd\nbed triggers when player enters or leaves a bed (entering bed can be cancelled)\n\nThe command procedure you assign to the bed event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("bed")\n%args%[2] name of the spawned player\n%args%[3] either "enter" or "leave"\n%args%[4] name of the level (world) the bed is in\n%args%[5] the X coordinate of the beds position\n%args%[6] the Y coordinate of the beds position\n%args%[7] the Z coordinate of the beds position\n\nIf the player is entering the bed, you can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n\nYou cannot cancel leaving bed.\n```')
    elif cmd.lower() == "gm":
        await ctx.send('```cmd\ngm triggers when player switches gamemode (can be cancelled)\n\nThe command procedure you assign to the gm event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("gm")\n%args%[2] name of the player whose gamemode is being changed\n%args%[3] the new gamemode requested\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n```')
    elif cmd.lower() == "eat":
        await ctx.send('```cmd\neat triggers when player eats food (can be cancelled)\n\nThe command procedure you assign to the eat event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("eat")\n%args%[2] name of the player trying to eat\n%args%[3] ID of the item being eaten\n%args%[4] Damage value of the item being eaten\n%args%[5] Name of the item being eaten\n%args%[6] Tags of the item being eaten, if any\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n```')
    elif cmd.lower() == "chat":
        await ctx.send('```cmd\nchat triggers when player writes message in chat (can be cancelled)\n\nThe command procedure you assign to the chat event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("chat")\n%args%[2] name of the player trying to write in chat\n%args%[3] message the player has written\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n```')
    elif cmd.lower() == "damage":
        await ctx.send('```cmd\ndamage triggers when player or mob gets damage (can be cancelled)\n\nThe command procedure you assign to the damage event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("damage")\n%args%[2] name of the player getting damage\n%args%[3] name of the damager (whos caused the damage)\n%args%[4] ID of the damage cause\n%args%[5] Name of the damage cause\n%args%[6] Base amount of damage being caused before applying modifiers\n%args%[7] Final damage amount being applied to the player\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n```')
    elif cmd.lower() == "death":
        await ctx.send('```cmd\ndeath triggers when player dies\n\nThe command procedure you assign to the death event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("death")\n%args%[2] name of the player killed\n%args%[3] name of the damager (whos killed the player)\n%args%[4] ID of the damage cause that killed the player\n%args%[5] Name of the damage cause that killed the player\n\nYou cannot cancel this event.\n```')
    elif cmd.lower() == "cheat":
        await ctx.send('```cmd\ncheat triggers when player tries to cheat (can be cancelled)\n\nThe command procedure you assign to the cheat event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("cheat")\n%args%[2] name of the player trying to cheat\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n\nNote that not all kinds of cheats can be detected.\n```')
    elif cmd.lower() == "place":
        await ctx.send('```cmd\nplace triggers when player places a block (can be cancelled)\n\nThe command procedure you assign to the place event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("place")\n%args%[2] name of the player trying to place the block\n%args%[3] name of the level (world) the block is being placed in\n%args%[4] the X coordinate of the position the block is being placed at\n%args%[5] the Y coordinate of the position the block is being placed at\n%args%[6] the Z coordinate of the position the block is being placed at\n%args%[7] ID of the item being placed\n%args%[8] Variant (meta) value of the item being placed\n%args%[9] Name of the item being placed\n%args%[10] Tags of the item being placed, if any\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n```')
    elif cmd.lower() == "break":
        await ctx.send('```cmd\nbreak triggers when player breaks a block (can be cancelled)\n\nThe command procedure you assign to the break event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("break")\n%args%[2] name of the player trying to break the block\n%args%[3] name of the level (world) the block is being broken in\n%args%[4] the X coordinate of the position of the block being broken\n%args%[5] the Y coordinate of the position of the block being broken\n%args%[6] the Z coordinate of the position of the block being broken\n%args%[7] ID of the tool being used to break the block\n%args%[8] Variant (meta) value of the tool being used to break the block\n%args%[9] Name of the tool being used to break the block\n%args%[10] Tags of the tool being used to break the block, if any\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n```')
    elif cmd.lower() == "touch":
        await ctx.send('```cmd\ntouch triggers when player touches a block (can be cancelled)\n\nThe command procedure you assign to the touch event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("touch")\n%args%[2] name of the player trying to touch the block\n%args%[3] name of the level (world) the block is being touched in\n%args%[4] the X coordinate of the position of the block being touched\n%args%[5] the Y coordinate of the position of the block being touched\n%args%[6] the Z coordinate of the position of the block being touched\n%args%[7] ID of the tool/item being used to touch the block (if any)\n%args%[8] Variant (meta) value of the tool/item being used to touch the block\n%args%[9] Name of the tool/item being used to touch the block\n%args%[10] Tags of the tool/item being used to touch the block, if any\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n```')
    elif cmd.lower() == "appear":
        await ctx.send('```cmd\nappear triggers when a new entity is spawned\n\nThe command procedure you assign to the appear event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("appear")\n%args%[2] name/type of the entity spawned\n%args%[3] further specification of the entity, if available\n%args%[4] name of the level (world) the entity was spawned in\n%args%[5] the X coordinate of the position where the entity spawned\n%args%[6] the Y coordinate of the position where the entity spawned\n%args%[7] the Z coordinate of the position where the entity spawned\n\nThis event cannot be cancelled.\n\nWARNING: You command can trigger extremely often on a busy server, so make sure to exit fast if you\'re not interested in processing it further.\n```')
    elif cmd.lower() == "disappear":
        await ctx.send('```cmd\ndisappear triggers when an entity is despawned\n\nThe command procedure you assign to the appear event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("disappear")\n%args%[2] name/type of the entity despawned\n%args%[3] further specification of the entity, if available\n%args%[4] name of the level (world) the entity despawned from\n%args%[5] the X coordinate of the position from where the entity despawned\n%args%[6] the Y coordinate of the position from where the entity despawned\n%args%[7] the Z coordinate of the position from where the entity despawned\nThis event cannot be cancelled.\n\nWARNING: You command can trigger extremely often on a busy server, so make sure to exit fast if you\'re not interested in processing it further.\n```')
    elif cmd.lower() == "hit":
        await ctx.send('```cmd\nhit triggers when an entity or a block is hit by a projectile\n\nThe command procedure you assign to the appear event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("hit")\n%args%[2] name/type of the target hit (i.e. "Dirt" or "Player")\n%args%[3] further specification of the target (player name, block data etc.)\n%args%[4] name/type of the projectile (i.e. "Arrow" or "Snowball")\n%args%[5] projectile owner\'s name, if available\n%args%[6] name of the level (world) the target got hit\n%args%[7] the X coordinate of the position where the target got hit\n%args%[8] the Y coordinate of the position where the target got hit\n%args%[9] the Z coordinate of the position where the target got hit\n\nNote that if the target is an entity, the damage event is triggered as well.\n\nThis event cannot be cancelled.\n```')
    elif cmd.lower() == "move-event":
        await ctx.send('```cmd\nmove triggers when player moves from or to a specified area\n\nTo prevent from running too often, the move event handler is not triggered on every player movement but only in cases when player enters or leaves specific cubic area in a specific level (world).\n\nThe command procedure you assign to the move event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("move")\n%args%[2] name of the player moving\n%args%[3] direction ("from" or "to")\n%args%[4] area name or "<level>[<x1>,<y1>,<z1>|<x2>,<y2>,<z2>]"\n```')
    elif cmd.lower() == "move":
        await ctx.send("```cmd\nType -help move-command to get help for the move command, or -help move-event to get help for the move event trigger.\n```")
    elif cmd.lower() == "permissions":
        await ctx.send("```cmd\nGrant or deny the following permissions to control who can define or use custom commands:\n\ncmd.edit - Create and manage custom defined commands, Default: Op\ncmd.edit.<command_name> - Manage specific command, Default: inherited from cmd.edit\ncmd.run - Execute custom commands without explicit permission defined, Default: Allow\ncmd.run.<command_name> - inherited from cmd.run if not specified\ncmd.<subcommand> - Use specific /cmd subcommand, Default: inherited from cmd.edit\n```")
    elif cmd.lower() == "license":
        await ctx.send("```cmd\nThis plugin is developed and maintained by madhon, available at madhon@mad-hon.com.\n\nThis plugin is distributed under a commercial license and you are only allowed to use it\nin the way and extent and under conditions explicitly agreed on with madhon in writing.\n```")
    elif cmd.lower() == "urlencode":
        await ctx.send('```cmd\nurlencode(<array>|<string>) encodes data to be used in url\n\nWhen calling a web URL using the geturl function, you may want to supply some parameters. To use in URL, parameters must be encoded, so that there are no invalid characters in the URL.\n\nFor example "This is $1,000,000 feature"\nbecomes "This+is+%241%2C000%2C000+feature"\n```')
    elif cmd.lower() == "dejson":
        await ctx.send('```cmd\ndejson(<string>) decodes JSON data to an array\n\nMost RESTful APIS today use JSON as format of the data they return. To let you easily work with JSON formatted results, the dejson function lets you convert any valid JSON to an array.\n\nEXAMPLE:\nIf you have a small phone directory available online at http://myphonedir.xyz/, returning the following JSON data:\n\n{"John" : "123-456-7890", "Frank" : "987-654-3210"}\n\nyou can create a phone lookup command procedure like this:\n\n1 let %directory% = geturl("http://myphonedir.xyz/")\n2 let %name% = %args%[1]\n3 if varset(%directory%[%name%]) then goto 6\n4 message %p% %name% not found in the directory\n5 exit\n6 let %phone% = %directory%[%name%]\n7 message %p% %name%s phone number is %phone%\n```')
    elif cmd.lower() == "split":
        await ctx.send('```cmd\nsplit(<string>, <delimiter>) converts string to an array\n\nFor example, if you have comma delimited list of players:\n\nlet %players% = "madhon, knedlik, nohdam, knedlok"\n\nYou can convert it to array of player names using:\n\nlet %names% = split(%players%, ", ")\n\nSee also the join function which can join an array back to a string.\n```')
    elif cmd.lower() == "join":
        await ctx.send('```cmd\njoin(<array>, <delimiter>) converts array to a string\n\nFor example, if you have an array of player names, just as the result from the example in the description of the split function, you can convert it back, but this time to a semicolon delimited list, using this command:\n\nlet %players% = join(%names%, "; ")\n```')
    elif cmd.lower() == "size":
        await ctx.send('```cmd\nsize(<array>|<string>) returns array elements count or string length\n\nIf you have a string variable %mystring%, this function lets you check its length in the number of characters:\n\nsize(%mystring%)\n\nif you have a variable %myarray% containing an array of values, you can check the number of items in the array:\n\nsize(%myarray%)\n\nYou can then easily loop through the array and perform some operation on each item.\n\nEXAMPLE:\n1 let %online% = onlineplayers()\n2 let %count% = size(%online%)\n3 message %p% There are %count% players online\n```')
    elif cmd.lower() == "array":
        await ctx.send('```cmd\narray(<value>[, <value>] ...) builds a flat array from supplied parameters\n\nThis function is useful mostly for quickly building arrays from literals.\n\nEXAMPLES:\n1 %day_names% = array("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat")\n2 %prime_numbers% = array(1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29)\n```')
    elif cmd.lower() == "varset":
        await ctx.send('```cmd\nvarset(<variable>) returns true if <variable> exists\n\nUse this function to check whether a variable or array element is set before using it as parameter for functions and commands to avoid producing errors and unwanted results.\n\nEXAMPLE:\n1 if varset(%args%[1]) then goto 4\n2 message %p% You have not provided any parameter\n3 exit\n4 let %parameter% = %args%[1]\n```')
    elif cmd.lower() == "random":
        await ctx.send('```cmd\nrandom(<min>, <max>) returns random integer number in the <min>..<max> range\n\nThis can be very important function for building minigames.\n\nEXAMPLE:\n1 let %teams% = array("RED", "BLUE")\n2 let %rnd% = random(0, 1)\n3 let %myteam% = %teams%[%rnd%]\n4 message %p% You have joined the %myteam% team\n```')
    elif cmd.lower() == "lowercase":
        await ctx.send('```cmd\nlowercase(<string>) converts string to lowercase letters\n\nIts as simple as that.\nYou can use this function on strings you want to compare if you want the comparison to be case insensitive.\n\nEXAMPLE:\nlowercase("Hello World") will return "hello world"\n```')
    elif cmd.lower() == "uppercase":
        await ctx.send('```cmd\nuppercase(<string>) converts string to uppercase letters\n\nIts as simple as that.\nYou can use this function on strings you want to compare if you want the comparison to be case insensitive.\n\nEXAMPLE:\nuppercase("Hello World") will return "HELLO WORLD"\n```')
    elif cmd.lower() == "substring":
        await ctx.send('```cmd\nsubstring(<string>, <start>, <length>) extracts part of a text string\n\nIn this function <start> is zero-based index of the first character to extract from the string. So if you pass 0 there, you will be extracting beginning of the string. You can also think of it as number of characters to skip from the beginning of the string.\n\nIf you have a string "Hello World, its me, madhon" and you want to extract just the word "madhon" out of it, you can do it like this:\n\nsubstring("Hello World, its me, madhon", 22, 6)\n\nThis function, however, supporst also special cases. For instance, using negative value for <start> will make it count the cahracters from the end of the string, not from the beginning. So you can extract "madhon" from the same string also this way:\n\nsubstring("Hello World, its me, madhon", -6, 6)\n```')
    elif cmd.lower() == "position":
        await ctx.send('```cmd\nposition(<array>|<string>, <substring>) returns position of substring in array or string\n\nIf the first parameter is string, this function returns zero-based position of the first occurrence of the substring it finds in the string.\n\nIf the first parameter is an array, it returns index of the first occurrence of array value matching the substring.\n\nIf the substring is not found, this function returns -1.\n\nEXAMPLES:\nposition("Hello world", "world") will return 6\nposition("Hello World", "world") will return -1 because it is case sensitive\nposition(array("Hello", "World"), "World") will return 1\n```')
    elif cmd.lower() == "replace":
        await ctx.send('```cmd\nreplace(<array>|<string>, <original>, <replacement>) replaces all occurrences of <original> in array or string with <replacement>\n\nIf the first parameter is string, this function simply finds all occurrences of the <original> in it and replaced is with <replacement>.\n\nIf the first parameter is an array, this function goes through all values of the array and performs the action on every one of them.\n\nThis function is case sensitive.\n\nEXAMPLES:\nreplace("Hello madhon", "madhon", "knedlik") will return "Hello knedlik"\nreplace("Hello %p", "%p", %p) when run by knedlik will return "Hello knedlik"\nreplace(array("red onion", "red dwarf", "blue dip"), "red", "cool") will return an array containing these values: ["cool onion", "cool dwarf", "blue dip"]\n```')
    elif cmd.lower() == "int":
        await ctx.send('```cmd\nint(<number>) returns integer part of number by cutting off the fractional part\n\nFor example, players coordinates are normally returned as precise float numbers, which is sometimes impractical when you only need the block-precision coordinates.\n\nSo you can use the int function to strip out the fractional part and get the integer part of each coordinate.\n\nEXAMPLE:\n1 let %xx% = int(%x%)\n2 let %yy% = int(%y%)\n3 let %zz% = int(%z%)\n4 popup %p% %xx% %yy% %zz%\n```')
    elif cmd.lower() == "onlineplayers":
        await ctx.send('```cmd\nonlineplayers([<filter>]) returns array of online player names\n\nIf you want a list of all players currently connected to your server, just use the function with no parameters:\n\nonlineplayers()\n\nIf you are lucky to have many players on your server and want to list just those who have "steve" somewhere in their nickname, you can filter the online players by providing a filter string:\n\nonlineplayers("steve")\n```')
    elif cmd.lower() == "playerstatus":
        await ctx.send('```cmd\nplayerstatus(<playername>) returns array of information about player\n\nThis function returns an associative array with these elements:\n\n["x"] Players x coordinate\n["y"] Players y coordinate\n["z"] Players z coordinate\n["yaw"] Players yaw (horizontal look direction)\n["pitch"] Players pitch (vertical look direction)\n["level"] Players level\n["gm"] Players gamemode\n["health"] Players health (0-20)\n["food"] Players food/hunger (0-20)\n["saturation"] Players saturation (0-14.4)\n["exhaustion"] Players exhaustion (0-4)\n["xplevel"] Players experience level (0-24791)\n["xpprogress"] Players experience progress within current level (0-1.0)\n["online"] True if the player is currently online\n["op"] True if the player is op\n["ip"] IP address from which the player is connected\n```')
    elif cmd.lower() == "playerarmor":
        await ctx.send('```cmd\nplayerarmor(<playername>) returns array of armor currently worn by player\n\nThis function returns an array of 4 elements:\n\n[0] item used as helmet\n[1] item used as chestplate/tunic\n[2] item used as pants\n[3] item used as boots\n\nEach of these elements is an associative arrays with these elements:\n\n["id"] ID of the item (0 for no armor)\n["damage"] Damage level of the item\n["name"] Name of the item, i.e. "Diamond Helmet"\n["tags"] Tags of the item, if any\n```')
    elif cmd.lower() == "playerinventory":
        await ctx.send('```cmd\nplayerinventory(<playername>) returns array of players survival inventory\n\nThis function returns an array of items the player has in the survival inventory. Each element of this array is an associative arrays with these elements:\n\n["id"] ID of the item (0 for no armor)\n["variant"] Meta value or damage level of the item\n["count"] Count of the items held in single inventory slot\n["name"] Name of the item\n["tags"] Tags of the item, if any\n```')
    elif cmd.lower() == "playerhand":
        await ctx.send('```cmd\nplayerhand(<playername>) returns item held by the player in hand\n\nThis function returns an associative array with these elements:\n\n["id"] ID of the item (0 for no armor)\n["variant"] Meta value or damage level of the item\n["count"] Count of the items held in single inventory slot\n["name"] Name of the item\n["tags"] Tags of the item, if any\n["invslot"] ID of the inventory slot the item in hand is from\n```')
    elif cmd.lower() == "playerbalance":
        await ctx.send('```cmd\nplayerbalance(<playername>) returns economy money balance of the player\n\nThis function returns current economy money balance of the specified player.\nYou can use this function to check whether the player has enough money to pay for using\nyour command before you try to take money from his/her account.\n```')
    elif cmd.lower() == "playergroup":
        await ctx.send('```cmd\nplayergroup(<playername>) returns PurePerms group/rank of the player\n\nThis function returns name of the group the specifief player has assigned in PurePerms.\nYou can use this function to check whether the player is member of certain group (has certain rank) in order to decide whether/how specific command will work for him/her.\n```')
    elif cmd.lower() == "blockinfo":
        await ctx.send('```cmd\nblockinfo(<level>, <x>, <y>, <z>) returns array of information about world block\n\nThis function returns an associative array with these elements:\n\n["id"] ID of the item (0 for no armor)\n["variant"] Meta value or damage level of the item\n["name"] Name of the item\n["data"] Any custom data stored with the block\n```')
    elif cmd.lower() == "blockcontents":
        await ctx.send('```cmd\nblockcontents(<level>, <x>, <y>, <z>) returns contents of block, such as chest or sign\n\nThis function returns an array of items the specified block holds in its inventory.\n\nFor chests each element of this array is an associative arrays with these elements:\n\n["id"] ID of the item (0 for no armor)\n["variant"] Meta value or damage level of the item\n["count"] Count of the items held in single inventory slot\n["name"] Name of the item\n["tags"] Tags of the item, if any\n\nFor item frames, the array contains one element which is an associative array with these elements:\n\n["id"] ID of the item (0 for no armor)\n["variant"] Meta value or damage level of the item\n["count"] Count of the items held in single inventory slot\n["name"] Name of the item\n["tags"] Tags of the item, if any\n["rotation"] Rotation of the item (between 0 and 7)\n["dropchance"] Chance that the will be dropped when breaking the frame (float value between 0 and 1)\n\nFor signs, the array contains exactly four elements, each of which is a string representing one line of text from the sign:\n\n[0] first line of text\n[1] second line of text\n[2] third line of text\n[3] fourth line of text\n```')
    elif cmd.lower() == "areaname":
        await ctx.send('```cmd\nareaname(<level>, <x>, <y>, <z>) returns name of protected area for position\nareaname(<playername>) returns name of protected area player is in\n\nThis function returns name of the protected area surrounding specified player or position, if there is one defined by LEET Land Protection.\n```')
    elif cmd.lower() == "areainfo":
        await ctx.send('```cmd\nareainfo(<areaname>[, <playername>]) returns information about protected area\n\nThis function returns an array with information about named area protected by LEET Land Protection.\n\nResult of this function is an associative arrays with these elements:\n\n["level"] Level name the protected area is defined in\n["bounds"] Array of two elements, each of which is array of one corner\'s coordinates\n["flags"] Default flags for the area, or player\'s flags if player name provided\n["whitelist"] Array of players who have individual flags definted for the area\n```')
    elif cmd.lower() == "dialog":
        await ctx.send('```cmd\ndialog(<player>, <form_data>) shows dialog to player and returns response\n\nThis function can be used to prompt specific player for some information and get it back as a response.\n\n<form_data> must be an associative array, containing the following elements:\n\n["title"] text string to use as a dialog title\n["type"] must be one of: "modal" | "form" | "custom_form"\n\nDepending on the dialog type, additional values must be provided.\n\nFor "modal" dialog (simple dialog with two buttons):\n\n["content"] text string to display in the dialog as description\n["button1"] name of first button, pressing this will return true\n["button2"] name of second button, pressing this will return false\n\nResult of the "modal" dialog is a boolean value.\n\nFor "form" dialog (simple form with one ore more buttons and optional images):\n\n["content"] text string to display in the dialog as description\n["buttons"] associative array of button definitions:\n["buttons"]["text"] button name\n["buttons"]["image"] array containing image parameters\n["buttons"]["image"]["type"] image type (only "url" supported)\n["buttons"]["image"]["data"] image url\n\nResult of the "form" dialog is either zero-based index of the pressed button, or boolean false if the player has closed the dialog without pressing a button.\n\nFor "custom_form" dialog:\n\n["content"] array of dialog items, each item represented by an array with the following elements:\n\n["content"]["type"] one of "label" | "input" | "dropdown" | "slider" | "step_slider" | "toggle"\n\n["content"]["text"] text to display as label\n["content"]["default"] default string value for "input" item\n["content"]["placeholder"] value placeholder for "input" item\n["content"]["options"] array of values for "dropdown" item\n["content"]["min"] minimum value for "slider" item\n["content"]["max"] maximum value for "slider" item\n["content"]["steps"] array of step names for "step_slider" item\n```')
        await ctx.send('```cmd\n["content"]["default"] either %true% or %false% for "toggle" item\n\nResult of the "custom_form" dialog is an array of values entered in individual items, or boolean false if the player has closed the dialog without pressing the Submit button.\n\nFor "dropdown" and "step_slider" items the value returned is zero-based index of the selected option.\n\nCommand procedure execution is paused while waiting for the players response. In the case of the player leaving server without responding to the dialog, execution is resumed and the function returns boolean false.\n```')
    else:
        await ctx.send("```cmd\nType -help <topicname> to show more details about:\n\nediting: how to define and edit your custom commands\nusage: how to run your custom commands\ncommands special commands to use in your scripts\nexpressions: how to write expressions and calculations\noperators: list of supported binary operatory\nfunctions: list of supported functions\nvariables: list of special pre-defined variables\nevents: list of supported event names\npermissions: permission nodes you can use\nlicense: license conditions for using this plugin\n```")

@bot.command(pass_context=True)
async def report(ctx, *, args=None):
    if args == None:
        embed = discord.Embed(name="", description="", color=0xff0000)
        embed.add_field(name="Usage", value="-report <report message...>", inline=True)
        await ctx.send(embed=embed)
    else:
        me = await bot.get_user_info('352898973578690561')
        await bot.send_message(me, "Report from `{}`: `{}`".format(ctx.message.author, args))
        await ctx.send(":white_check_mark: Successfully reported!")

@bot.command(pass_context=True)
async def cmd(ctx, command=None):
    if command == None:
        embed = discord.Embed(name="", description="Here is a list of available commands.", color=0x00FFFF)
        embed.add_field(name="Commands", value="-cmd\n-help\n-tutorial\n-tutadd\n-invite\n-report\n-about", inline=True)
        embed.set_footer(text="Type -cmd <command> to get more info about a specific command.", icon_url=embed.Empty)
        await ctx.send(embed=embed)
    elif command.lower() == "cmd":
        embed = discord.Embed(name="cmd", description="Get a list of available commands", color=0x00FFFF)
        embed.add_field(name="Usage", value="-cmd [command]", inline=True)
        await ctx.send(embed=embed)
    elif command.lower() == "help":
        embed = discord.Embed(name="help", description="Get help of the topics in MadCommands", color=0x00FFFF)
        embed.add_field(name="Usage", value="-help [topic]", inline=True)
        await ctx.send(embed=embed)
    elif command.lower() == "tutorial":
        embed = discord.Embed(name="tutorial", description="Get a list of tutorial commands and their codes", color=0x00FFFF)
        embed.add_field(name="Usage", value="-tutorial <list / command_name>", inline=True)
        await ctx.send(embed=embed)
    elif command.lower() == "report":
        embed = discord.Embed(name="report", description="Report an issue with the bot", color=0x00FFFF)
        embed.add_field(name="Usage", value="-report <report message..>", inline=True)
        await ctx.send(embed=embed)
    elif command.lower() == "tutadd":
        embed = discord.Embed(name="tutadd", description="Add a command to (-tutorial list)", color=0x00FFFF)
        embed.add_field(name="Usage", value="-tutadd <command info..>", inline=True)
        await ctx.send(embed=embed)
    elif command.lower() == "invite":
        embed = discord.Embed(name="invite", description="Invite the bot to your server", color=0x00FFFF)
        embed.add_field(name="Usage", value="-invite", inline=True)
        await ctx.send(embed=embed)
    elif command.lower() == "about":
        embed = discord.Embed(name="about", description="Gives credits and info about the bot", color=0x00FFFF)
        embed.add_field(name="Usage", value="-about", inline=True)
        await ctx.send(embed=embed)
    else:
        embed = discord.Embed(name="", description="Here is a list of available commands.", color=0x00FFFF)
        embed.add_field(name="Commands", value="-cmd\n-help\n-tutorial\n-tutadd\n-setprefix\n-invite\n-report", inline=True)
        embed.set_footer(text="Type -cmd <command> to get more info about a specific command.", icon_url=embed.Empty)
        await ctx.send(embed=embed)

@bot.command(pass_context=True)
async def tutadd(ctx, *, args=None):
    if args == None:
        embed = discord.Embed(name="", description="", color=0xff0000)
        embed.add_field(name="Usage", value="-tutadd <command info..>", inline=True)
        embed.set_footer(text="Please make sure to add the command name, description, usage and code.", icon_url=embed.Empty)
        await ctx.send(embed=embed)
    else:
        me = await bot.get_user_info('352898973578690561')
        await bot.send_message(me, "Command from `{}`:\n{}".format(ctx.message.author, args))
        await ctx.send(":white_check_mark: Successfully sent the command info to **Acsrel#3657**, please wait until **Acsrel** read the command info and add it.")

@bot.command(pass_context=True)
async def tutorial(ctx, args=None, page=None):
    if args == None:
        embed = discord.Embed(name="", description="", color=0xff0000)
        embed.add_field(name="Usage", value="-tutorial <list / (command_name)>", inline=True)
        await ctx.send(embed=embed)
    elif args.lower() == "list":
        if page == None or page == "1":
            embed = discord.Embed(name="Tutorials List", description="", color=0x00ffff)
            embed.add_field(name="Page 1/3", value="- Heal\n- Calculate-Activity\n- Vanish\n - Hud\n- Freeze/Unfreeze", inline=True)
            embed.set_footer(text="Type -tutorial list <page> to go to another page // Type -tutorial <command_name> to get the info of the command (usage, description, name, code)", icon_url=embed.Empty)
            await ctx.send(embed=embed)
        elif page == "2":
            embed = discord.Embed(name="Tutorials List", description="", color=0x00ffff)
            embed.add_field(name="Page 2/3", value="- CheckOP\n- StaffChat\n- GUIForm\n- GUIModal\n- GUICustomForm", inline=True)
            embed.set_footer(text="Type -tutorial list <page> to go to another page // Type -tutorial <command_name> to get the info of the command (usage, description, name, code)", icon_url=embed.Empty)
            await ctx.send(embed=embed)
        elif page == "3":
            embed = discord.Embed(name="Tutorials List", description="", color=0x00ffff)
            embed.add_field(name="Page 3/3", value="- Feed\n- Warn/Warns\n- Mute/Unmute\n- DetectPlayer\n- BossBar", inline=True)
            embed.set_footer(text="Type -tutorial list <page> to go to another page // Type -tutorial <command_name> to get the info of the command (usage, description, name, code)", icon_url=embed.Empty)
            await ctx.send(embed=embed)
    elif args.lower() == "heal":
        await ctx.send("**Command Name:** Heal.\n**Command Description:** Heal yourself or another player.\n**Command Usage:** /heal [player]\n**Command Author:** Acsrel#3657\n**Command Code:**\n```cmd\ncmd create heal Heal your self or another player\ncmd add heal let %player% = %args%[1]\ncmd add heal if varset(%player%) then goto 6\ncmd add heal treat %p% 20\ncmd add heal message %p% aYou have been healed!\ncmd add heal exit\ncmd add heal if %player% notin onlineplayers() then message %p% c%player% is not online!\ncmd add heal if %player% notin onlineplayers() then exit\ncmd add heal treat %player% 20\ncmd add heal message %p% aHealed %player%!\ncmd add heal exit\n```")
    elif args.lower() == "calculate-activity" or args.lower() == "calculate" or args.lower() == "activity" or args.lower() == "calculateactivity":
        await ctx.send("**Command Name:** Calculate-Activity.\n**Command Description:** Calculate how long players have been online.\n**Command Usage:** This command is automatic, you don't manually use it\n**Command Author**: Ammar#7494\n**Command Code:**\n```cmd\ncmd create join Login event | Not for manual use\ncmd add join load %last-join%\ncmd add join let %last-join%[%p%] = %time%\ncmd add join save %last-join%\ncmd unregister join\ncmd trigger login join\n\ncmd create leave Leave event | Not for manual use\ncmd add leave load %last-join%\ncmd add leave %elapsed% = %time% - %last-join%[%p%]\ncmd add leave load %activity%\ncmd add leave if varset(%activity%[%p%]) = %false% then %activity%[%p%] = 0\ncmd add leave %activity%[%p%] = %activity%[%p%] + %elapsed%\ncmd add leave save %activity%\ncmd unregister leave\ncmd trigger leave leave\n```")
    elif args.lower() == "vanish":
	    await ctx.send('**Command Name:** Vanish.\n**Command Description:** Makes you vanished.\n**Command Usage:** /vanish\n**Command Author:** Acsrel#3657\n**Command Code:**\n```cmd\ncmd create vanish\ncmd add vanish let %status% = playerstatus(%p%)\ncmd add vanish let %op% = %status%["op"]\ncmd add vanish if %op% = %false% then message %p% cOnly OPs can use this command!\ncmd add vanish if %op% = %false% then exit\ncmd add vanish load %vanish%\ncmd add vanish if varset(%vanish%[%p%]) = %false% then let %vanish%[%p%] = \\"false\\"\ncmd add vanish if %vanish%[%p%] = \\"true\\"  then goto 13\ncmd add vanish ascon /effect %p% invisibility 999999 1 true\ncmd add vanish message %p% You are now vanished!\ncmd add vanish let %vanish%[%p%] = \\"true\\"\ncmd add vanish save %vanish%\ncmd add vanish exit\ncmd add vanish ascon /effect %p% clear\ncmd add vanish message %p% You are no longer vanished!\ncmd add vanish let %vanish%[%p%] = \\"false\\"\ncmd add vanish save %vanish%\ncmd add vanish exit\n```')
    elif args.lower() == "hud":
	    await ctx.send('**Command Name:** Hud.\n**Command Description:** Turn your superbar on/off.\n**Command Usage:** /hud <on|off>\n**Command Author:** ChinaGirlNL#5723\n**Command Code:**\n```cmd\ncmd create hud Turn the hud on|off\ncmd add hud if varset(%args%[1]) = %false% then message %p% Usage: /hud <on|off>\ncmd add hud if varset(%args%[1]) = %false% then exit\ncmd add hud %a% = %args%[1]\ncmd add hud if %a% = \\"off\\" then goto 100\ncmd add hud if %a% = \\"on\\" then goto 50\ncmd add hud message %p% Usage: /hud <on|off>\ncmd add hud exit\ncmd edit hud 49 #on\ncmd add hud %hudr%[%p%] = \\"on\\"\ncmd add hud save %hudr%\ncmd add hud exit\ncmd edit hud 99 #off\ncmd add hud %hudr%[%p%] = \\"off\\"\ncmd add hud save %hudr%\ncmd add hud popup %p% \ncmd add hud sleep 0.099\ncmd add hud load %hudr%\ncmd add hud if %hudr%[%p%] = \\"off\\" then goto 102\ncmd add hud exit\n```')
    elif args.lower() == "freeze/unfreeze" or args.lower() == "freeze" or args.lower() == "unfreeze" or args.lower() == "freezeunfreeze":
        await ctx.send('**Command Name:** Freeze/Unfreeze.\n**Command Description:** Freezes a player and unfreezes a frozen player.\n**Command Usage:** /freeze <player> | /unfreeze <player>\n**Command Author:** Acsrel#3657\n**Command Code:**\n```cmd\ncmd create freeze Freeze a player\ncmd insert freeze 1 let %player% = %args%[1]\ncmd insert freeze 2 if varset(%player%) then goto 5\ncmd insert freeze 3 message %p% Usage: /freeze <player>\ncmd insert freeze 4 exit\ncmd insert freeze 5 let %online% = onlineplayers()\ncmd insert freeze 6 if %player% in %online% then goto 9\ncmd insert freeze 7 message %p% c%player% is not online, or the name is incorrect.\ncmd insert freeze 8 exit\ncmd insert freeze 9 load %frozen%\ncmd insert freeze 10 if varset(%frozen%[%player%]) then goto 12\ncmd insert freeze 11 let %frozen%[%player%] = \\"false\\"\ncmd insert freeze 12 if %frozen%[%player%] = \\"true\\" then goto 27\ncmd insert freeze 13 let %info% = playerstatus(%player%)\ncmd insert freeze 14 let %xx% = %info%["x"]\ncmd insert freeze 15 let %yy% = %info%["y"]\ncmd insert freeze 16 let %zz% = %info%["z"]\ncmd insert freeze 17 let %world% = %info%["level"]\ncmd insert freeze 18 let %frozen%[%player%] = \\"true\\"\ncmd insert freeze 19 save %frozen%\ncmd insert freeze 20 message %p% a%player% has been frozen!\ncmd insert freeze 21 load %frozen%\ncmd insert freeze 22 # space\ncmd insert freeze 23 move %player% %world% %xx% %yy% %zz%\ncmd insert freeze 24 sleep 0.2\ncmd insert freeze 25 if %frozen%[%player%] = \\"true\\" then goto 21\ncmd insert freeze 26 exit\ncmd insert freeze 27 message %p% c%player% is already frozen!\ncmd insert freeze 28 exit```')
        await ctx.send('```cmd create unfreeze Unfreeze a frozen player\ncmd insert unfreeze 1 let %player% = %args%[1]\ncmd insert unfreeze 2 if varset(%player%) then goto 5\ncmd insert unfreeze 3 message %p% Usage: /unfreeze <player>\ncmd insert unfreeze 4 exit\ncmd insert unfreeze 5 let %online% = onlineplayers()\ncmd insert unfreeze 6 if %player% in %online% then goto 9\ncmd insert unfreeze 7 message %p% c%player% is not online, or the name is incorrect.\ncmd insert unfreeze 8 exit\ncmd insert unfreeze 9 load %frozen%\ncmd insert unfreeze 10 if %frozen%[%player%] = \\"true\\" then goto 13\ncmd insert unfreeze 11 message %p% c%player% is not frozen!\ncmd insert unfreeze 12 exit\ncmd insert unfreeze 13 let %frozen%[%player%] = \\"false\\"\ncmd insert unfreeze 14 save %frozen%\ncmd insert unfreeze 15 message %p% a%player% has been unfrozen!\ncmd insert unfreeze 16 exit\n```')
    elif args.lower() == "checkop":
	    await ctx.send('**Command Name:** CheckOP.\n**Command Description:** Show a list of online operators.\n**Command Usage:** /checkop\n**Command Author:** ChinaGirlNL#5723\n**Command Code:**\n```cmd\ncmd create checkop\ncmd add checkop message %p% Online operators:\ncmd add checkop %on% = onlineplayers()\ncmd add checkop %num% = int(0)\ncmd add checkop %pc% = %on%[%num%]\ncmd add checkop %stat% = playerstatus(%pc%)\ncmd add checkop if %stat%[\\"op\\"] = %true% then message %p% -%pc%\ncmd add checkop %length% = size(%on%) - 1\ncmd add checkop if %num% = %length% then exit\ncmd add checkop %num% = %num% + 1\ncmd add checkop goto 4\n```')
    elif args.lower() == "staffchat":
        await ctx.send('**Command Name:** Staff Chat.\n**Command Description:** Toggles a private chat between staff.\n**Command Usage:** /sc <add / list / remove / enable / disable>\n**Command Author:** Acsrel#3657\n**Command Code:**\n```cmd\ncmd create sc Staff chat\ncmd add sc load %staff%\ncmd add sc if varset(%staff%) then goto 5\ncmd add sc let %staff% = array()\ncmd add sc let %staff% = %staff% - array()\ncmd add sc load %enabled%\ncmd add sc if varset(%enabled%[%p%]) = %false% then let %enabled%[%p%] = \\"false\\"\ncmd add sc if (%args%[1] = \\"add\\") or (%args%[1] = \\"list\\") or (%args%[1] = \\"remove\\") or (%args%[1] = \\"enable\\") or (%args%[1] = \\"disable\\") then goto 12\ncmd add sc if %enabled%[%p%] = \\"true\\" then goto 600\ncmd add sc if %p% in %staff% then goto 12\ncmd add sc message %p% cOnly staff members can run this command.\ncmd add sc exit\ncmd add sc let %option% = %args%[1]\ncmd add sc if %option% = \\"add\\" then goto 100\ncmd add sc if %option% = \\"list\\" then goto 200\ncmd add sc if %option% = \\"remove\\" then goto 300\ncmd add sc if %option% = \\"enable\\" then goto 400\ncmd add sc if %option% = \\"disable\\" then goto 500\ncmd add sc if %option% = \\"chat\\" then goto 603\ncmd add sc message %p% Usage: /sc <add / list / remove / enable / disable>\ncmd add sc exit\n```')
        await ctx.send('```cmd insert sc 100 # add\ncmd add sc let %status% = playerstatus(%p%)\ncmd add sc let %op% = %status%["op"]\ncmd add sc if %op% = %false% then message %p% cOnly OPs can use this command.\ncmd add sc if %op% = %false% then exit\ncmd add sc let %player% = %args%[2]\ncmd add sc if varset(%player%) = %false% then message %p% Usage: /sc add <player>\ncmd add sc if varset(%player%) = %false% then exit\ncmd add sc let %staff% = array(%staff%, %player%)\ncmd add sc save %staff%\ncmd add sc message %p% aSuccessfully added %player% to the staff list.\ncmd add sc exit\ncmd insert sc 200 # list\ncmd add sc message %p% bStaff list:\ncmd add sc message %p% %staff%\ncmd add sc exit\ncmd insert sc 300 # remove\ncmd add sc let %status% = playerstatus(%p%)\ncmd add sc let %op% = %status%["op"]\ncmd add sc if %op% = %false% then message %p% cOnly OPs can use this command.\ncmd add sc if %op% = %false% then exit\ncmd add sc let %player% = %args%[2]\ncmd add sc if varset(%player%) = %false% then message %p% Usage: /sc remove <player>\ncmd add sc if varset(%player%) = %false% then exit\ncmd add sc if %player% notin %staff% then message %p% c%player% is not in the staff list.\ncmd add sc if %player% notin %staff% then exit\ncmd add sc let %staff% = %staff% - array(%player%)\ncmd add sc save %staff%\ncmd add sc message %p% aSuccessfully removed %player% from the staff list.\ncmd add sc exit\ncmd insert sc 400 # enable\ncmd add sc load %enable%\ncmd add sc let %enable%[%p%] = \\"true\\"\ncmd add sc save %enable%\ncmd add sc message %p% aStaff chat enabled.\ncmd add sc exit\ncmd insert sc 500 # disable\ncmd add sc load %enabled%\ncmd add sc let %enabled% = \\"false\\"\ncmd add sc save %enabled%\ncmd add sc message %p% aStaff chat disabled.\ncmd add sc exit\ncmd insert sc 600 # chat\ncmd add sc ascon /sc chat\ncmd add sc exit\ncmd add sc cancel\ncmd add sc let %msg% = %args%[3]\ncmd add sc message %staff% 7[6StaffChat7] b%p% > %msg%\ncmd add sc exit\ncmd trigger chat sc\n```')
    elif args.lower() == "guiform":
        await ctx.send('**Command Name:** GUI Form.\n**Command Description:** An example of a GUI form.\n**Command Usage:** /guiform\n**Command Author:** Acsrel#3657\n**Command Code:**\n```cmd\ncmd create guiform GUI type form\ncmd add guiform %player% = %p%\ncmd add guiform if varset(%args%[1]) then %player% = %args%[1]\ncmd add guiform %gui%[\\"type\\"] = \\"form\\"\ncmd add guiform %gui%[\\"title\\"] = \\"GUI Form\\"\ncmd add guiform %gui%[\\"content\\"] = \\"An example of a GUI form\\"\ncmd add guiform %button1%[\\"text\\"] = \\"Button 1\\"\ncmd add guiform %button2%[\\"text\\"] = \\"Button 2\\"\ncmd add guiform %button3%[\\"text\\"] = \\"Button 3\\"\ncmd add guiform %buttons%[] = %button1%\ncmd add guiform %buttons%[] = %button2%\ncmd add guiform %buttons%[] = %button3%\ncmd add guiform %gui%[\\"buttons\\"] = %buttons%\ncmd add guiform %response% = dialog(%player%, %gui%)\ncmd add guiform if %response% = 0 then message %p% You tapped the first button.\ncmd add guiform if %response% = 1 then message %p% You tapped the second button.\ncmd add guiform if %response% = 2 then message %p% You tapped the third button.\n```')
    elif args.lower() == "guimodal":
        await ctx.send('**Command Name:** GUI Modal.\n**Command Description:** An example of a GUI modal.\n**Command Usage:** /guimodal\n**Command Author:** Acsrel#3657\n**Command Code:**\n```cmd\ncmd create guimodal GUI type modal\ncmd add guimodal %player% = %p%\ncmd add guimodal if varset(%args%[1]) then %player% = %args%[1]\ncmd add guimodal %gui%[\\"type\\"] = \\"modal\\"\ncmd add guimodal %gui%[\\"title\\"] = \\"GUI Modal\\"\ncmd add guimodal %gui%[\\"content\\"] = \\"An example of a GUI modal\\"\ncmd add guimodal %gui%[\\"button1\\"] = \\"True\\"\ncmd add guimodal %gui%[\\"button2\\"] = \\"False\\"\ncmd add guimodal %response% = dialog(%player%, %gui%)\ncmd add guimodal if %response% = %true% then message %p% You tapped on true.\ncmd add guimodal if %response% = %false% then message %p% You tapped on false.\n```')
    elif args.lower() == "guicustomform":
        await ctx.send('**Command Name:** GUI Custom Form.\n**Command Description:** An example of a GUI custom form.\n**Command Usage:** /guicustomform\n**Command Author:** Acsrel#3657\n**Command Code:**')
        await ctx.send('```\ncmd create guicustomform GUI type custom_form\ncmd add guicustomform %gui%[\\"type\\"] = \\"custom_form\\"\ncmd add guicustomform %gui%[\\"title\\"] = \\"GUI Custom Form\\"\ncmd add guicustomform %item0%[\\"type\\"] = \\"label\\"\ncmd add guicustomform %item0%[\\"text\\"] = \\"This is label item.\\"\ncmd add guicustomform %item1%[\\"type\\"] = \\"dropdown\\"\ncmd add guicustomform %item1%[\\"text\\"] = \\"This is dropdown item.\\"\ncmd add guicustomform %item1%[\\"options\\"] = array(\\"Option 0\\", \\"Option 1\\", \\"Option 2\\")\ncmd add guicustomform %item2%[\\"type\\"] = \\"input\\"\ncmd add guicustomform %item2%[\\"text\\"] = \\"This is input item.\\"\ncmd add guicustomform %item2%[\\"default\\"] = \\"This is default value.\\"\ncmd add guicustomform %item2%[\\"placeholder\\"] = \\"This is placeholder\\"\ncmd add guicustomform %item3%[\\"type\\"] = \\"slider\\"\ncmd add guicustomform %item3%[\\"text\\"] = \\"This is slider item\\"\ncmd add guicustomform %item3%[\\"min\\"] = 0\ncmd add guicustomform %item3%[\\"max\\"] = 100\ncmd add guicustomform %item4%[\\"type\\"] = \\"step_slider\\"\ncmd add guicustomform %item4%[\\"text\\"] = \\"This is step_slider item\\"\ncmd add guicustomform %item4%[\\"steps\\"] = array(\\"Zero\\", \\"One\\", \\"Two\\", "Three\\", \\"Four\\")\n cmd add guicustomform %item5%[\\"type\\"] = \\"toggle\\"\ncmd add guicustomform %item5%[\\"text\\"] = \\"This is toggle item\\"\ncmd add guicustomform %item5%[\\"default\\"] = %false%\ncmd add guicustomform %content%[] = %item0%\ncmd add guicustomform %content%[] = %item1%\ncmd add guicustomform %content%[] = %item2%\ncmd add guicustomform %content%[] = %item3%\ncmd add guicustomform %content%[] = %item4%\ncmd add guicustomform %content%[] = %item5%\ncmd add guicustomform %gui%[\\"content\\"] = %content%\ncmd add guicustomform %response% = dialog(%player%, %gui%)\ncmd add guicustomform if varset(%response%) then message %p% Your response is: %response%\n```')
    elif args.lower() == "feed":
        await ctx.send('**Command Name:** Feed.\n**Command Description:** Feed yourself or another player.\n**Command Usage:** /feed [player]\n**Command Author:** Acsrel#3657\n**Command Code:**\n```cmd\ncmd create feed Feed your self or another player\ncmd add feed let %player% = %args%[1]\ncmd add feed if varset(%player%) then goto 8\ncmd add feed let %status% = playerstatus(%p%)\ncmd add feed let %saturation% = %status%["saturation"]\ncmd add feed treat %p% %health% %saturation% 20\ncmd add feed message %p% aYou have been fed!\ncmd add feed exit\ncmd add feed if %player% notin onlineplayers() then message %p% c%player% is not online!\ncmd add feed if %player% notin onlineplayers() then exit\ncmd add feed let %status% = playerstatus(%player%)\ncmd add feed let %saturation% = %status%["saturation"]\ncmd add feed treat %player% %health% %saturation% 20\ncmd add feed message %p% aFed %player%!\ncmd add feed exit\n```')
    elif args.lower() == "warn/warns" or args.lower() == "warn" or args.lower() == "warns" or args.lower() == "warnwarns":
        await ctx.send('**Command Name:** Warn/Warns\n**Command Description:** Warn someone and check someones warns.\n**Command Usage:** /warn <player> [reason] | /warns [player]\n**Command Author:** Acsrel#3657\n**Command Code:**\n```cmd\ncmd create warn Warn a player\ncmd add warn let %player% = lowercase(%args%[1])\ncmd add warn if varset(%player%) = %false% then message %p% Usage: /warn <player> [reason]\ncmd add warn if varset(%player%) = %false% then exit\ncmd add warn if varset(%args%[2+]) then let %reason% = join(%args%[2+], \\" \\")\ncmd add warn if varset(%args%[2+]) = %false% then let %reason% = \\"No reason given.\\"\ncmd add warn let %full% = \\"\\ n\\" + %player% + \\" has been warned by \\" + %p% + \\" for \\" + %reason%\ncmd add warn load %warn%\ncmd add warn if varset(%warn%[%player%]) = %false% then let %warn%[%player%] = \\"\\"\ncmd add warn let %warn%[%player%] = %warn%[%player%] + %full%\ncmd add warn save %warn%\ncmd add warn message onlineplayers() 7l(c!7) c%player% fhas been warned by c%p% ffor c%reason% 7(c!7)\ncmd add warn exit\n```')
        await ctx.send('```\ncmd create warns Check your warnings or another player warnings\ncmd add warns let %player% = lowercase(%args%[1])\ncmd add warns if varset(%player%) then goto 12\ncmd add warns load %warn%\ncmd add warns let %pp% = lowercase(%p%)\ncmd add warns if varset(%warn%[%pp%]) = %false% then let %warnings% = \\"No warnings\\"\ncmd add warns if varset(%warn%[%pp%]) then let %warnings% = %warn%[%pp%]\ncmd add warns message %p% c========\ncmd add warns message %p% %warnings%\ncmd add warns message %p% r\ncmd add warns message %p% c========\ncmd add warns exit\ncmd add warns load %warn%\ncmd add warns if varset(%warn%[%player%]) = %false% then let %warnings% = \\"No warnings\\"\ncmd add warns if varset(%warn%[%player%]) then let %warnings% = %warn%[%player%]\ncmd add warns message %p% c========\ncmd add warns message %p% %warnings%\ncmd add warns message %p% r\ncmd add warns message %p% c========\ncmd add warns exit\n```')
    elif args.lower() == "mute/unmute" or args.lower() == "mute" or args.lower() == "unmute" or args.lower() == "muteunmute":
        await ctx.send('**Command Name:** Mute/Unmute\n**Command Description:** Mute someone or unmute a muted player\n**Command Usage:** /mute <player> | /unmute <player>\n**Command Author:** Acsrel#3657\n**Command Code:**\n```cmd\ncmd create mute Mute a player\ncmd add mute let %player% = lowercase(%args%[1])\ncmd add mute if varset(%player%) = %false% then message %p% Usage: /mute <player>\ncmd add mute if varset(%player%) = %false% then exit\ncmd add mute load %muted%\ncmd add mute let %muted%[%player%] = \\"true\\"\ncmd add mute save %muted%\ncmd add mute message %p% a%player% is now muted.\ncmd add mute exit\n```')
        await ctx.send('```\ncmd create unmute Unmute a muted player\ncmd add unmute let %player% = lowercase(%args%[1])\ncmd add unmute if varset(%player%) = %false% then message %p% Usage: /unmute <player>\ncmd add unmute if varset(%player%) = %false% then exit\ncmd add unmute load %muted%\ncmd add unmute let %muted%[%player%] = \\"false\\"\ncmd add unmute save %muted%\ncmd add unmute message %p% a%player% is now unmuted.\ncmd add unmute exit\n```')
        await ctx.send('```\ncmd create chat Chat trigger\ncmd add chat let %player% = lowercase(%args%[2])\ncmd add chat load %muted%\ncmd add chat if varset(%muted%[%player%]) = %false% then exit\ncmd add chat if %muted%[%player%] = \\"true\\" then cancel\ncmd trigger chat chat\n```')
    elif args.lower() == "detectplayer" or args.lower() == "detect":
        await ctx.send('**Command Name** Detect Player\n**Command Description:** To be able to Detect if player is inside a chosen set area with cords.\n**Command Usage:** /detect\n**Command Author:** HBIDamian#1337\n**Note:** Make sure you put the correct cords in the right place for it to work, the "min" and "max" variables are the variables to edit to make this work.\n**Command Code:**\n```cmd\ncmd create detect\ncmd add detect let %minX% = 10\ncmd add detect let %minY% = 10\ncmd add detect let %minZ% = 10\ncmd add detect let %maxX% = 200\ncmd add detect let %maxY% = 200\ncmd add detect let %maxZ% = 200\ncmd add detect let %status% = playerstatus(%p%)\ncmd add detect let %playerX% = %status%[\\"x\\"]\ncmd add detect let %playerY% = %status%[\\"y\\"]\ncmd add detect let %playerZ% = %status%[\\"z\\"]\ncmd add detect if (%playerX% >= %minX%) and (%playerX% <= %maxX%) and (%playerY% >= %minY%) and (%playerY% <= %maxY%) and (%playerZ% >= %minZ%) and (%playerZ% <= %maxZ%) then goto 14\ncmd add detect message %p% Outside of area\ncmd add detect exit\ncmd add detect message %p% Inside of Area\ncmd add detect exit\n```')
    elif args.lower() == "bossbar" or args.lower() == "boss":
        await ctx.send('**Command Name:** Boss Bar\n**Command Description:** Create, delete, show, hide, edit a boss bar.\n**Command Usage:** /boss <create / delete / show / hide / sethealth / settitle> <boss>\n**Command Author:** Acsrel#3657\n**Command Code:**')
        await ctx.send('```\ncmd create boss Boss Bar\ncmd insert boss 1 if varset(%args%[1]) = %false% then message %p% Usage: /boss <create / delete / show / hide / sethealth / settitle>\ncmd insert boss 2 if varset(%args%[1]) = %false% then exit\ncmd insert boss 3 %option% = %args%[1]\ncmd insert boss 4 if %option% = \\"create\\" then goto 100\ncmd insert boss 5 if %option% = \\"delete\\" then goto 200\ncmd insert boss 6 if %option% = \\"show\\" then goto 300\ncmd insert boss 7 if %option% = \\"hide\\" then goto 400\ncmd insert boss 8 if %option% = \\"sethealth\\" then goto 500\ncmd insert boss 9 if %option% = "settitle" then goto 600\ncmd insert boss 10 message %p% Usage: /boss <create / delete / show / hide / sethealth / settitle>\ncmd insert boss 11 exit\ncmd insert boss 100 # create\ncmd insert boss 101 if varset(%args%[2]) = %false% then message %p% Usage: /boss create <boss>\ncmd insert boss 102 if varset(%args%[2]) = %false% then exit\ncmd insert boss 103 %boss% = %args%[2]\ncmd insert boss 104 boss create %boss%\ncmd insert boss 105 load %bosses%\ncmd insert boss 106 %bosses%[] = %boss%\ncmd insert boss 107 save %bosses%\ncmd insert boss 108 message %p% aBoss create with the name %boss%.\ncmd insert boss 109 exit\ncmd insert boss 200 # delete\ncmd insert boss 201 if varset(%args%[2]) = %false% then message %p% Usage: /boss delete <boss>\ncmd insert boss 202 if varset(%args%[2]) = %false% then exit\ncmd insert boss 203 %boss% = %args%[2]\ncmd insert boss 204 load %bosses%\ncmd insert boss 205 if %boss% notin %bosses% then message %p% cThere isn\'t a boss with the name %boss%!\ncmd insert boss 206 if %boss% notin %bosses% then exit\ncmd insert boss 207 %bosses% = %bosses% - array(%boss%)\ncmd insert boss 208 save %bosses%\ncmd insert boss 209 boss delete %boss%\ncmd insert boss 210 message %p% aBoss with the name %boss% has been deleted.\ncmd insert boss 211 exit\n```')
        await ctx.send('```\ncmd insert boss 300 # show\ncmd insert boss 301 if (varset(%args%[2]) = %false%) or (varset(%args%[3]) = %false%) then message %p% Usage: /boss show <boss> <player / all>\ncmd insert boss 302 if (varset(%args%[2]) = %false%) or (varset(%args%[3]) = %false%) then exit\ncmd insert boss 303 %boss% = %args%[2]\ncmd insert boss 304 load %bosses%\ncmd insert boss 305 if %boss% notin %bosses% then message %p% cThere isn\'t a boss with the name %boss%!\ncmd insert boss 306 if %boss% notin %bosses% then exit\ncmd insert boss 307 %player% = %args%[3]\ncmd insert boss 308 if (%player% = \\"all\\") or (%player% = \\"*\\") then %player% = onlineplayers()\ncmd insert boss 309 boss show %boss% %player%\ncmd insert boss 310 if %player% = onlineplayers() then message %p% aBoss %boss% has been shown to everybody.\ncmd insert boss 311 if %player% != onlineplayers() then message %p% aBoss %boss% has been shown to %player%.\ncmd insert boss 312 exit\ncmd insert boss 400 # hide\ncmd insert boss 401 if (varset(%args%[2]) = %false%) or (varset(%args%[3]) = %false%) then message %p% Usage: /boss hide <boss> <player / all>\ncmd insert boss 402 if (varset(%args%[2]) = %false%) or (varset(%args%[3]) = %false%) then exit\ncmd insert boss 403 %boss% = %args%[2]\ncmd insert boss 404 load %bosses%\ncmd insert boss 405 if %boss% notin %bosses% then message %p% cThere isn\'t a boss with the name %boss%!\ncmd insert boss 406 if %boss% notin %bosses% then exit\ncmd insert boss 407 %player% = %args%[3]\ncmd insert boss 408 if (%player% = \\"all\\") or (%player% = \\"*\\") then %player% = onlineplayers()\ncmd insert boss 409 boss hide %boss% %player%\ncmd insert boss 410 if %player% = onlineplayers() then message %p% aBoss %boss% has been hidden from everybody.\ncmd insert boss 411 if %player% != onlineplayers() then message %p% aBoss %boss% has been hidden from %player%.\ncmd insert boss 412 exit\n```')
        await ctx.send('```\ncmd insert boss 500 # sethealth\ncmd insert boss 501 if (varset(%args%[2]) = %false%) or (varset(%args%[3]) = %false%) then message %p% Usage: /boss sethealth <boss> <health>\ncmd insert boss 502 if (varset(%args%[2]) = %false%) or (varset(%args%[3]) = %false%) then exit\ncmd insert boss 503 %boss% = %args%[2]\ncmd insert boss 504 load %bosses%\ncmd insert boss 505 if %boss% notin %bosses% then message %p% cThere isn\'t a boss with the name %boss%!\ncmd insert boss 506 if %boss% notin %bosses% then exit\ncmd insert boss 507 %hp% = %args%[3]\ncmd insert boss 508 if (%hp% < 0) or (%hp% > 1) then message %p% cThe boss health must be from 0 to 1!\ncmd insert boss 509 if (%hp% < 0) or (%hp% > 1) then exit\ncmd insert boss 510 boss health %boss% %hp%\ncmd insert boss 511 message %p% aBoss %boss% health has been set to %hp%.\ncmd insert boss 512 exit\ncmd insert boss 600 # settitle\ncmd insert boss 601 if (varset(%args%[2]) = %false%) or (varset(%args%[3]) = %false%) then message %p% Usage: /boss settitle <boss> <title>\ncmd insert boss 602 if (varset(%args%[2]) = %false%) or (varset(%args%[3]) = %false%) then exit\ncmd insert boss 603 %boss% = %args%[2]\ncmd insert boss 604 load %bosses%\ncmd insert boss 605 if %boss% notin %bosses% then message %p% cThere isn\'t a boss with the name %boss%!\ncmd insert boss 606 if %boss% notin %bosses% then exit\ncmd insert boss 607 %title% = join(%args%[3+], \\" \\")\ncmd insert boss 608 boss title %boss% %title%\ncmd insert boss 609 message %p% aBoss %boss% title has been set to %title%.\ncmd insert boss 610 exit\n```')
    else:
        embed = discord.Embed(name="", description="", color=0xff0000)
        embed.add_field(name="Usage", value="-tutorial <list / command_name>", inline=True)
        await ctx.send(embed=embed)

@bot.command(pass_context=True)
async def invite(ctx):
    if ctx.message.server == None:
        embed = discord.Embed(name="", description="", color=0x00FFFF)
        embed.add_field(name="Invite the bot to your discord server", value="[Click here](https://discordapp.com/api/oauth2/authorize?client_id=489013863467974660&permissions=8&scope=bot)", inline=True)
        await ctx.send(embed=embed)
    elif ctx.message.server.id == "382669571934388245":
        await ctx.send("This command is disabled in the leet discord server.")
    else:
        embed = discord.Embed(name="", description="", color=0x00FFFF)
        embed.add_field(name="Invite the bot to your discord server", value="[Click here](https://discordapp.com/api/oauth2/authorize?client_id=489013863467974660&permissions=8&scope=bot)", inline=True)
        await ctx.send(embed=embed)

@bot.command(pass_context=True)
async def about(ctx):
    embed = discord.Embed(name="", description="", color=0x00FFFF)
    embed.add_field(name="About the bot", value="This bot was created and developed by Acsrel#3657, This bot is about a Pocketmine-MP plugin called MadCommands.", inline=True)
    await ctx.send(embed=embed)

bot.run(os.environ['BOT_TOKEN'])
