# MadCommands v2.1.6 build 1047

import discord
from discord.ext.commands import Bot
from discord.ext import commands
import os
import asyncio

Client = discord.Client()
bot = commands.Bot(command_prefix='-')
bot.remove_command("help")
description = "-cmd | XMagmaCreeperX"

@bot.event
async def on_ready():
    print("==================================")
    print("MadCommands v2.1.6 build 1047")
    print(" ")
    print("Bot is ready")
    print(" ")
    print("Im in {} servers".format(len(bot.servers)))
    print("==================================")
    await bot.change_presence(game=discord.Game(name="-cmd | XMagmaCreeperX"))

@bot.event
async def on_server_join(server):
    await bot.send_message(server.owner, "Thank you **{}** for inviting me to your server: **{}**!\nMy prefix  is **-**\nType **-cmd** for the help menu.\n\nThis bot was coded by XMagmaCreeperX#3657".format(server.owner, server.name))
    me = await bot.get_user_info('352898973578690561')
    await bot.send_message(me, "===============================\nI have joined the server:\nName: **{}**\nID: **{}**\nOwner: **{}**\n\nIm in {} servers\n===============================".format(server.name, server.id, server.owner, len(bot.servers)))

@bot.command(pass_context=True)
async def help(ctx, cmd=None):
    if cmd == None:
        await bot.say("```\nType -help <topicname> to show more details about:\n\nediting: how to define and edit your custom commands\nusage: how to run your custom commands\ncommands special commands to use in your scripts\nexpressions: how to write expressions and calculations\noperators: list of supported binary operatory\nfunctions: list of supported functions\nvariables: list of special pre-defined variables\nevents: list of supported event names\npermissions: permission nodes you can use\nlicense: license conditions for using this plugin\n```")
    elif cmd =="editing":
        await bot.say("```\nThese commands will let you define custom commands and their procedures:\n\n/cmd install [<command_name>]\n/cmd create <command_name> [<description> [ | <usage>]]\n/cmd modify <command_name> <new_name> [<description> [ | <usage>]]\n/cmd delete <command_name> [<start_line_number>[..<end_line_number>]]\n/cmd add <command_name> [asop|ascon] <command> [<parameter>] ...\n/cmd edit <command_name> <line_number> [asop|ascon] <command> [<parameter>] ...\n/cmd insert <command_name> <line_number> [asop|ascon] <command> [<parameter>] ...\n/cmd list [<command_name>] [<start_line_number>[..<end_line_number>]]\n/cmd enable <command_name>\n/cmd disable <command_name>\n/cmd register <command_name>\n/cmd unregister <command_name>\n/cmd trigger [<event_name> [<command_name>]]\n/cmd config [<option_name> [<new_value>]]\n/cmd run <command> [<parameter>] ...\n/cmd running [<command_id>]\n/cmd kill <command_id>\n\nType -help <command> to get detailed help for a specific command.\n```")
    elif cmd == "install":
        await bot.say("```\nThe /cmd install command can be used to install pre-defined command procedures from an external repository.\n\nTyping simply /cmd install with no extra parameters will list all available commands in the repository.\n\nUse /cmd install <command_name> to install specific command of your choice.\n\nBy default, madhon's repository is used. You can repoint the plugin to a different repository by modifying the install-source config option.\n\nEXAMPLES:\n/cmd install\n/cmd install countdown\n```")
    elif cmd == "create":
        await bot.say("```\nUse /cmd create <command_name> to create a new command procedure.\n\nIf you want your procedure to be registered as a regular command, you can also provide optional description and usage for the standard /help command:\n\n/cmd create <command_name> <description> | <usage>\n\nAfter the command is registered, users can use /help <command_name> to check the command's description and usage.\n\nWhether new commands are automatically enabled and/or registered when created can be controlled by modifying the enable-new-commands and register-new-commands config options.\n\nEXAMPLES:\n/cmd create hello\n/cmd create hello This command says hello | /hello\n```")
    elif cmd == "modify":
        await bot.say("```\nYou can use /cmd modify to rename an already defined custom command or to change its description and usage displayed by the /help command.\n\nTo just rename your command use /cmd modify <command_name> <new_name>\n\nTo modify rename your command AND modify its description, use:\n\n/cmd modify <command_name> <new_name> <new_description> | <new_usage>\n\nEXAMPLES:\n/cmd modify hello hi\n/cmd modify hello hello Say hello to online players\n/cmd modify hi hi Say hi to everyone | /hi\n```")
    elif cmd == "delete":
        await bot.say("```\nUse this command to delete either one or more lines from your custom command procedure or the whole procedure.\n\nTo delete a single line from your custom command procedure, use:\n/cmd delete <command_name> <line_number>\n\nTo delete multiple lines from your custom command procedure, use:\n/cmd delete <command_name> <start_line_number>..<end_line_number>\n\nTo delete whole custom command, use:\n/cmd delete <command_name>\n\nEXAMPLES:\n/cmd delete hello 2\n/cmd delete hello 11..25\n/cmd delete hello\n```")
    elif cmd == "add":
        await bot.say("```\nUse /cmd add to add a new command line to the end of your custom command procedure:\n\n/cmd add <command_name> [asop|ascon] <command> [<parameter>] ...\n\nNote that regular game commands need to be typed exactly as you would type them in the chat - including the leading forward slash character.\n\nIf you precede your command with ascon, this line will be executed from the console context. This has the advantage of bypassing any permission checking, but can only be used for commands that do work from the console context.\n\nIf you precede your command with asop, the player executing your procedure will be temporarily given Op permissions for the time of this line's execution, but the command itself will still be executed from the player's context.\n\nEXAMPLES:\n/cmd add makememember /me is now member\n/cmd add makememember ascon /setgroup %p% Member\n/cmd add makememember message %p% You are now member\n```")
    elif cmd == "edit":
        await bot.say("```\nYou can use the /cmd edit command to replace an existing line in your custom command procedure, or to create one with any line number of your choice:\n\n/cmd edit <command_name> <line_number> [asop|ascon] <command> [<parameter>] ...\n\nIf a line with the specified number already exists, it will be replaced with your new command. If the line does not exist, it will be added without modifying any other lines of the procedure.\n\nUsing a custom line number is very helpful when you want to jump to another part of your procedure using the goto command but don't know how many lines of code you will need to write between the two parts yet. Common practice used by BASIC programmers is to initially number all lines by the multiplies of 10, so that you can insert extra commands in between without having to renumber the following lines.\n\nType /cmd help add to learn about the ascon and asop options.\n\nEXAMPLES:\n/cmd edit hello 10 /say Nice to see you here\n/cmd edit hello 5 /say Hello everyone!\n/cmd edit hello 7 exit\n```")
    elif cmd == "insert":
        await bot.say("```\nUse /cmd insert when you need to insert an extra command line between already existing lines of your procedure and you have not skipped any line number for later use:\n\n/cmd insert <command_name> <line_number> [asop|ascon] <command> [<parameter>] ...\n\nThis command will increment all line numbers immediately following the line number you're inserting, until a skipped line number of end of procedure is found.\n\nNote that any existing goto commands will remain unchanged, so remember to verify they are still pointing to the right lines after doing the insert.\n\nType /cmd help add to learn about the ascon and asop options.\n\nEXAMPLES:\n/cmd insert hello 5 /spawn\n```")
    elif cmd == "list":
        await bot.say("```\nThis command lists existing custom command procedures or their commands.\n\nTo display a list of all defined custom command procedures, simply type /cmd list with no extra parameters.\n\nTo display all command lines of a specific custom command procedure, type /cmd list <command_name>.\n\nIf your procedure is very long and you want to display only portion of it, you can also specify the range of command line numbers to display:\n\n/cmd list <command_name> <start_line_number>..<end_line_number>\n\nEXAMPLES:\n/cmd list\n/cmd list countdown\n/cmd list copyblock 1..10\n```")
    elif cmd == "enable":
        await bot.say("```\nUse this command to enable a command procedure that has not been enabled yet (if you have automated enabling of new commands turned off) or that has been previously disabled.\n\n/cmd enable <command_name>\n\nYou can control whether newly created commands are automatically enabled by modifying the enable-new-commands config option.\n```")
    elif cmd == "disable":
        await bot.say("```\nUse this command to disable a command procedure. When disabled, the command procedure does exist and can be edited, but cannot be executed.\n\n/cmd disable <command_name>\n\nYou can control whether newly created commands are automatically enabled by modifying the enable-new-commands config option.\n```")
    elif cmd == "register":
        await bot.say("```\nUse this command to register a custom command to be recognized as a proper /command. When registered, your command will be recognized by the game, as well as by the /help command.\n\n/cmd register <command_name>\n\nIf you register a custom command with the same name as an already existing regular command, your procedure will be used to override the standard functionality. You can still call the original command from within the procedure.\n\nNote that while newly registered commands can be used even from within the console, overriding existing commands only works in the player context.\n\nYou can control whether newly created commands are automatically registered by modifying the register-new-commands config option.\n```")
    elif cmd == "unregister":
        await bot.say("```\nUse this command to stop your command procedure from being automatically registered as a proper command when starting the server. Since PocketMine does not currently support unregistering a single command, you have to restart your server for the command to finally stop working.\n\n/cmd unregister <command_name>\n\nYou can control whether newly created commands are automatically registered by modifying the register-new-commands config option.\n```")
    elif cmd == "trigger":
        await bot.say("```\nMadCommands is able to trigger your custom command procedures when specific things happen in the game.\n\nTo make your command procedure automatically run whenever the desired event happens, use the following command:\n\n/cmd trigger <event_name> [to|from <area>] <command_name>\n\nTo unassign your command procedure from the event, simply use the same command without specifying command name:\n\n/cmd trigger <event_name> [to|from <area>]\n\nFor the move event, area can be specified either as a named area defined by LeetProtector or as a combination of level name and coordinates in one of the following forms:\n\n<level> <x1> <z1> <x2> <z2>\n<level> <x1> <y1> <z1> <x2> <y2> <z2>\n<level>[<x1>,<y1>,<z1>|<x2>,<y2>,<z2>]\n\nTo list all current triggers, simply type /cmd trigger\n\nWhen an event triggers your command procedure it passes some event-specific data to it as parameters. To learn more about individual events supported by this version of MadCommands, type /cmd help events.\n\nEXAMPLES:\n/cmd trigger\n/cmd trigger login welcome\n/cmd trigger death\n/cmd trigger move from world 0 0 255 255 leftspawn\n```")
    elif cmd == "config":
        await bot.say("```\nThe MadCommands plugin can be configured using the config.yml file placed in the plugin's folder. However, you can also check and modify some of the config options without having to restart the server and without even having access to the config file.\n\nTo check the current config and see what config options you have access to from within the game, simply type /cmd config with no extra parameters.\n\nTo check the current value of a specific config option, type:\n/cmd config <option_name>\n\nTo modify the config option, use the following syntax:\n/cmd config <option_name> <new_value>\n\nEXAMPLES:\n/cmd config\n/cmd config user-configurable-options\n/cmd config register-new-commands false\n```")
    elif cmd == "run":
        await bot.say("```\nUse this command to run a custom command you have enabled but not registered.\n\n/cmd run <command> [<parameter>]\n```")
    elif cmd == "running":
        await bot.say("```\nUse this command to get information about commands that are currently running.\n\nTo get a list of all running commands type:\n\n/cmd running\n\nTo get detailed information about specific running command, use:/cmd running <command_id>\n\nNote that you can only get information about paused commands and commands running in async worker this way because only one command can be running in the server thread at a moment, including the commund listing all running commands.\n```")
    elif cmd == "kill":
        await bot.say("```\nThis command lets you ask a running command to exit.\n\n/cmd kill <command_id>|all\n\nThis can become handy when you accidentally (or intentionally) create an endless loop and override the command execution timeout by using sleep or switching between sync and sync modes often enough.\n```")
    elif cmd == "usage":
        await bot.say("```\nUse your custom command the same way as you would use any other command:\n\n/<command_name> [<parameter>] ...\n\nor use /cmd run to run it from context where custom commands don't work:\n\n/cmd run <command_name> [<parameter>] ...\n```")
    elif cmd == "commands":
        await bot.say("```\nThese commands can be used only as part of your custom command procedures:\n\ngoto <line_number>\nexit\n\nsleep <seconds>\nschedule <seconds> <command> [<parameter>] ...\nasync\nsync\n\nif <expression> then <command> [<parameter>] ...\n\nlet %<variable_name>% = <expression>\nlet %<variable_name>%[] = <expression>\nlet %<variable_name>%[<number>] = <expression>\nlet %<variable_name>%[""<text>""] = <expression>\nlet %<variable_name>%[%<variable_name>%] = <expression>\n\nsave %<variable_name>%\nload %<variable_name>%\n\nmessage <player_name>|<players_array> <message>\ntip <player_name>|<players_array> <message>\naction <player_name>|<players_array> <message>\npopup <player_name>|<players_array> <multi_line_message>\ntitle <player_name>|<players_array> <two_line_message>\n\ndrop <level> <x> <y> <z> <item_id>[:<meta>]\nblock <level> <x> <y> <z> <block_id>[:<meta>] [<x2> <y2> <z2>]\nstore <level> <x> <y> <z> <items_array>\nwrite <level> <x> <y> <z> <sign_text>\ncarry <player_name> <items_array>\nwear <player_name> <items_array>\nhold <player_name> <item_id>[:<meta>]\nmove <player_name> <level> <x> <y> <z> [<yaw> [<pitch>]]\ntreat <player_name> <health> [<saturation> [<food> [<exhaustion>]]]\nxp <player_name> <xp_level> <xp_progress>\n\ncancel\n\n# <comments>\n\nType /cmd help <command> to get detailed help for a specific command.\nType /cmd help comments to learn about using comments.\n```")
    elif cmd == "goto":
        await bot.say("```\nUse this command to jump to a specific command line:\n\ngoto <line_number>\n\nYou can use this command to create loops or to skip certain lines depending on specific conditions. Make sure to use this command in combination with if-then to avoid endless loops.\n\nEXAMPLE:\n1 do something\n2 if condition then exit\n3 goto 1\n```")
    elif cmd == "exit":
        await bot.say("```\nUse the exit command whenever you want to exit the command procedure immediately:\n\nexit\n\nThis is useful for exiting loops or to stop execution of unfinished command procedure you're debugging.\n\nEXAMPLE:\n1 do something\n2 if condition then exit\n3 goto 1\n```")
    elif cmd == "sleep":
        await bot.say("```\nUse the sleep command to wait for certain amount of time before performind the following commands:\n\nsleep <seconds>\n\nNote that when used in the main thread, this command schedules a delayed task to execute the remaining commands. When the scheduled task is started, the command procedure timeout is reset as if the procedure was just starting, so you can effectively use the sleep command to keep a long procedure running without timing out and without blocking the server for too long.\n\nUsing sleep in async mode causes the command procedure to simply wait, and timeout defined in the plugin configuration still applies.\n\nCheck the proc-max-time and proc-max-time-async config options to find out what timeouts are applies in sync and async execution modes respectively.\n\nEXAMPLE:\n1 sleep 600\n2 message %p% Ten minues elapsed, the eggs must be finished now\n```")
    elif cmd == "schedule":
        await bot.say("```\nUse this command to schedule another command procedure to be executed later:\n\nschedule <seconds> <command_name> [<parameter>] ...\n\nThis command works almost like /cmd run except for that it does not run the procedure immediately but instead schedules it to run later.\n\nThe specified command procedure needs to be enabled but does not have to be registered as command.\n\nYou cannot schedule any commands using this command, only command procedures created by MadCommands. You can, however, schedule the same procedure, turning it to a regularly repeated task.\n\nEXAMPLE:\n1 /say ding-dong\n2 schedule 3600 chime\n```")
    elif cmd == "async":
        await bot.say("```\nThis command switches the currently running command procedure to the asynchronous mode.\n\nasync\n\nIn asynchronous mode, the following commands are executed in an asynchronous task, not blocking the main server thread.\n\nUse this to perform actions that take long time, such as complex calculations, and do not need to interact with the game, to avoid unnecessary lags.\n\nNote that game commands cannot be used in asynchronous mode because accessing the main thread's data structures from an async task would cause the server to crash.\n\nUse the sync command to switch back to synchronous execution mode.\n\nEXAMPLE:\n1 let %inventory% = playeinventory(%p%)\n2 async\n3-19 examine and adjust player's inventory\n20 sync\n21 carry %p% %inventory%\n```")
    elif cmd == "sync":
        await bot.say("```\nThis command switched the currently running command procedure back to synchronous execution mode after it was switched to asynchronous mode with the async command:\n\nsync\n\nType /cmd help async to learn more about asynchronous execution.\n```")
    elif cmd == "if":
        await bot.say("```\nThe if-then command lets you execute command only if certain condition is met. The syntax loks like this:\n\nif <expression> then <command> [<parameter>] ...\n\nWhat it does is that it first evaluates the expression entered between the word if and the word then. If the result of the expression is true or a valid non-zero number, or a non-empty string, then the command entered after the word then is executed. If the result of the expression is false or zero, or an empty string, then the rest of the command is simply ignored.\n\nThis is the most important command to be able to implement any kind of logic and decision-making in your command procedures, so necessary to make complex features, such as minigames.\n\nEXAMPLES:\n1 ascon if %p% = 'madhon' then /op %p%\n2 if %y% > 127 then message %p% You're flying too high\n3 load %past_participants%\n3 if %p% notin %past_participants% then goto 10\n4 message %p% You have already played this game\n5 exit\n```")
    elif cmd == "let":
        await bot.say('```\nUse the let command to assign value to a variable.\n\nMadCommands requires every variable name to be enclosed by the percent (%) signs, i.e. %x% or %mylongvariablename%. This limitation is to make the plugin slightly easier to develop and faster to parse your commands. It makes it also easy to use variables in game commands and have them replaced with their values when executing the commands.\n\nTo simply assign result of an expression to a variable, use:\n\nlet %<variable_name>% = <expression>\n\nMadCommands also supports arrays (one variable containing multiple values), both sequential and associative. If you want to add a new value to the end of an array, use empty square brackets:\n\nlet %<variable_name>%[] = <expression>\n\nTo assign value to a specific index of an array, include the desired index in the square brackets. Index can be either number or string:\n\nlet %<variable_name>%[<number>] = <expression>\n\nlet %<variable_name>%["<text>"] = <expression>\n\nYou can also use another variable as an index. In that case the value of the variable is used as index:\n\nlet %<variable_name>%[%<variable_name>%] = <expression>\n\nTo delete variable, simply assign nothing to it:\n\nlet %<variable_name% =\nlet %<variable_name>%[<number>] =\nlet %<variable_name>%["<text>"] =\n\nYou can use any combination of letters, numbers, underscores, and dashes as variable name, as long as it starts with a letter.\n\nYou cannot, however, use the let command to assign values to any of the pre-defined variables, such as %p%, %x%, or %time%. Type /cmd help variables to learn about pre-defined variables.\n\nYou can use any variable as part of any commands parameters. Each variable will be replaced with its value when executing the command. You cannot, however, directly reference array elements this way. To use an array element in a command, you first have to assign it to a dedicated variable.\n\n\n```')
        await bot.say('```\nThe let command can be implicit. You can simply omit it and just begin the command with the variable name.\n\nEXAMPLES:\n1 let %a% = -123\n2 let %b% = "bbb"\n3 let %c% = %a%\n4 let %d%[3] = "three"\n5 let %d%[5] = "five"\n6 let %d%[] = "six"\n7 let %e%["a"] = %a%\n8 let %e%["d"] = %d%\n9 %e%[%b%] = %b%\n```')
    elif cmd == "save":
        await bot.say("```\nVariables normally exist only as long as your procedure is running. To keep value of any variable for later user, you can use the save command:\n\nsave %<variable_name>%\n\nSaved variable survives even server restarts, so is very useful for storing things like minigame leaderboards or per-player settings. Use the load command to reload previously saved variable.\n\nYou can use the save command from the async execution mode but be careful not to try to save the same variable from two places at the same time. It is generally safer to only save variables in the synchronous mode.\n\nEXAMPLE:\n1 load %members%\n2 if %p% notin %members% then let %members%[] = %p%\n3 save %members%\n```")
    elif cmd == "load":
        await bot.say("```\nUse the load command to reload any variable previously saved using the save command:\n\nload %<variable_name>%\n\nEXAMPLE:\n1 load %members%\n2 if %p% notin %members% then let %members%[] = %p%\n3 save %members%\n```")
    elif cmd == "message":
        await bot.say('```\nThe message command displays message to a player or list of players. The message appears in the chat just like any other message.\n\nTo display message to a single player, provide the players name as first parameter and the message as second parameter:\n\nmessage <player_name> <message>\n\nYou can provide a valid expression as a message. Otwherwise everything after the second space is considered the message.\n\nTo send a message to multiple players, provide a valid expression resulting in an array as the first parameter:\n\nmessage <players_array> <message>\n\nThe message will then get broadcasted to all players listed in the array.\n\nEXAMPLES:\n1 message %p% This is simple message\n2 message %p% "This is expression message"\n3 message %p% %args%[1+]\n4 message onlineplayers() This is simple broadcast\n5 message onlineplayers() "This is\\nmulti-line\\nbroadcast"\n```')
    elif cmd == "tip":
        await bot.say('```\nThe tip command works exactly like the message command, except for that the message is displayed in the bottom third of the players screen and fades away in a short moment.\n\ntip <player_name>|<players_array> <message>\n\nThe only difference between tip and action is that tip is displayed as text with a shadow, while action does not have any shadow.\n\nEXAMPLES:\n1 tip %p% This is simple tip\n2 sleep 1\n3 tip %p% "This is expression tip"\n4 sleep 1\n5 tip %p% %args%[1+]\n6 sleep 1\n7 tip onlineplayers() This is simple tip broadcast\n```')
    elif cmd == "action":
        await bot.say('```\nThe action command works exactly like the message command, except for that the message is displayed in the bottom third of the players screen and fades away in a short moment.\n\naction <player_name>|<players_array> <message>\n\nThe only difference between tip and action is that tip is displayed as text with a shadow, while action does not have any shadow.\n\nEXAMPLES:\n1 action %p% This is simple action\n2 sleep 1\n3 action %p% "This is expression action"\n4 sleep 1\n5 action %p% %args%[1+]\n6 sleep 1\n7 action onlineplayers() This is simple action broadcast\n```')
    elif cmd == "popup":
        await bot.say('```\nThe popup command works exactly like the message command, except for that the message is displayed right above the inventory hotbar rather than in the chat, and fades away in a short moment.\n\npopup <player_name>|<players_array> <two_line_message>\n\nUnlike the tip and action commands, popup can display multiple lines of text. In order to do that you need to supply the message as an expression, evaluating to a string with two or more lines of text. You can use the C-style escape sequence "\n" to include line break in a string.\n\nEXAMPLES:\n1 popup %p% This is simple popup\n2 sleep 1\n3 popup %p% "This is expression popup"\n4 sleep 1\n5 popup %p% %args%[1+]\n6 sleep 1\n7 popup onlineplayers() This is simple popup broadcast\n8 sleep 1\n9 popup %p% "This is\\ntwo-line popup"\n```')
    elif cmd == "title":
        await bot.say('```\nThe title command displays a big text title in the center of the players screen. It can also display a smaller subtitle beneath the main title if you supply a two-line message as a parameter.\n\ntitle <player_name>|<players_array> <two_line_message>\n\nThe title command works exactly like the message command in terms of specifying target players and message to display.\n\nIn order to do display also a subtitle you need to supply the message as an expression, evaluating to a string with two lines of text. You can use the C-style escape sequence "\\n" to include line break in a string.\n\nEXAMPLES:\n1 title %p% This is simple title\n2 sleep 1\n3 title %p% "This is expression title"\n4 sleep 1\n5 title %p% %args%[1+]\n6 sleep 1\n7 title onlineplayers() This is simple title broadcast\n8 sleep 1\n9 title %p% "This is title\\nThis is subtitle"\n```')
    elif cmd == "drop":
        await bot.say('```\nUse the drop command to drop an item at certain position of the game world/map, just like if it was dropped by a player or destroyed chest. You need to specify the level name and coordinates of the position where the dropped item is supposed to spawn:\n\ndrop <level> <x> <y> <z> <item_id>[:<meta>]\n\nAny player will then be able to collect the item, until it is automatically despawned.\n\nEXAMPLES:\n1 drop world 81 71 47 diamond_axe\n2 let %items% = array("diamond_sword", "gold_sword", "stone_sword", "wooden_sword")\n3 let %rnd% = random(0, 3)\n4 let %randomitem% = %items%[%rnd%]\n5 drop world 81 81 47 %randomitem%\n```')
    elif cmd == "block":
        await bot.say('```\nYou can use the block command to change a single block in the game world/map to anything you want. You need to specify the level name and coordinates of the block you want to change, and then the block id and optional metadata:\n\nblock <level> <x> <y> <z> <block_id>[:<meta>]\n\nIf you are setting a two-block item, such as bed ir double-chest (currently the only kinds of blocks supported this way), you have to specify coordinates of the second block as well:\n\nblock <level> <x> <y> <z> <block_id>[:<meta>] <x2> <y2> <z2>\nYou can specify the block by its numeric ID (i.e. 1 for stone), or by its name defined by PocketMine (i.e. "stone").\n\nWARNING: Although you can set multiple blocks in a loop, this command is not intended for automated building or filling of large areas, because every single block change produces update to be sent to all players in visible distance just like if a player in creative mode placed the block there. Setting too many blocks by a single procedure might cause significant lags. However, you can efficiently use this for resetting minigame elements, opening or closing hidden doors, etc.\n\nEXAMPLES:\n1 block world 81 71 47 stone2 block world 82 71 47 1:1\n3 block world 83 71 47 bed:3\n4 block world 84 71 47 26:11\n5 block world 86 71 47 bed 85 71 47\n```')
    elif cmd == "store":
        await bot.say('```\nUse the store command to store items in a blocks inventory:\n\nstore <level> <x> <y> <z> <items_array>\n\nCurrently only chests, trapped chests, and item frames are supported.\n\nFor item frames, the supplied items array is supposed to contain only one item. If you specify the item as an array also containing the "ItemRotation" node, you can have the item in the item frame rotated as desired.\n\nThe easiest way to prepare an array of items for use with the store command is to get it from another block of the same kind using the blockcontents function.\n\nNote: The store and write commands are internally the same, so you can use them interchangebly. This makes it easier to copy block including its contents regardless of whether it is a sign, chest, or item frame.\n\nEXAMPLE:\n0 # This works if there is a chest at 77,71,47\n1 let %items% = blockcontents("world", 77, 71, 47)\n2 block world 81 71 47 chest\n3 store world 81 71 47 %items%\n```')
    elif cmd == "write":
        await bot.say('```\nUse the write command to modify sign text:\n\nwrite <level> <x> <y> <z> <sign_text>\n\nThe block at the specified coordinates must be a sign.\n\n<sign_text> must be a valid expression resulting in either a text string with up to four lines of text, or an array of text strings. You can use the C-style escape sequence "\\n" to include line break in a string literal.\n\nNote: The store and write commands are internally the same, so you can use them interchangibly. This makes it easier to copy block including its contents regardless of whether it is a sign, chest, or item frame.\n\nEXAMPLE:\n1 block world 81 71 47 sign\n2 write world 81 71 47 "line 1\\nline 2\\nline 3\\nline 4"\n3 block world 82 71 47 sign\n4 write world 82 71 47 array("line 1", "line 2", "line 3", "line 4")\n```')
    elif cmd == "carry":
        await bot.say('```\nThe carry command sets players inventory, making him carry the items you have specified:\n\ncarry <player_name> <items_array>\n\nThe easiest way to prepare an array of items for use with the carry command is to get it from a player using the playerinventory function.\n\nEXAMPLE:\n1 let %items% = playerinventory("player1")\n2 carry player2 %items%\n```')
    elif cmd == "wear":
        await bot.say('```\nThe wear command sets players armor, making him wear the clothes you have specified:\n\nwear <player_name> <items_array>\n\nThe easiest way to prepare an array of items for use with the wear command is to get it from a player using the playerarmor function.\n\nEXAMPLE:\n1 let %items% = playerarmor("player1")\n2 wear player2 %items%\n```')
    elif cmd == "hold":
        await bot.say("```\nThe hold command sets item in player's hand, making him hold the item you have specified:\n\nhold <player_name> <item_id>[:<meta>]\n\nIf the specified item is already in the player's hotbar, the existing hotbar slot is selected. If the item is not in the player's hotbar but there is an empty slot in the hotbar, the empty slot is selected and the item is put into it. If there's no empty slot in the player's hotbar, the currently selected hotbar slot's contents is replaced by the item.\n```")
    elif cmd == "move-command":
        await bot.say("```\nThe move command moves (teleports) player to the specified world and position:\n\nmove <player_name> <level> <x> <y> <z> [<yaw> [<pitch>]]\n\nThis commands is able to set also player's yaw (horizontal direction he's looking in) and pitch (vertical direction).\n```")
    elif cmd == "treat":
        await bot.say("```\nThe treat command adjusts player's health and hunger condition:\n\ntreat <player_name> <health> [<saturation> [<food> [<exhaustion>]]]\n\nWith this command, you can directly set (reset) player's:\n\n- health (in the range from 0 to 20)\n- saturation (in the range from 0 to 20)\n- food (in the range from 0 to 20 - more food means less hungry)\n- exhaustion (in the range from 0 to 5)\n\nOnly health is mandatory parameter, remaining parameters are optional.\n\nEXAMPLES:\ntreat madhon 20\ntreat herobrine 1 0 1 5\n```")
    elif cmd == "xp":
        await bot.say("```\nThe xp command sets player's Xp level and progress:\n\nmove <player_name> <xp_level> <xp_progress>\n\nXp level can be set to any integer value between 0 and 24791, Xp progress can be set to anything between 0 and 1. For example, Xp progress of 0.3 stands for 30% experience progress at the current level.\n```")
    elif cmd == "cancel":
        await bot.say("```\nIn a command procedure started by a cancellable event trigger the cancel command will mark the originating event to be cancelled. In rare cases, cancellation can still be overridden by another plugin.\n\nThe cancel command is used simply alone, without any parameters:\n\ncancel\n\nType cmd help events to learn what events are supported and which ones can be cancelled.\n```")
    elif cmd == "#":
        await bot.say("```\nIf you want to add comments to your procedures to make them easier to understand, simply add lines beginning with the hash (#) character:\n\n# <comments>\n\nAny line beginning with the hash is simply ignored when executing the procedure, so the execution continues at the following line.\n```")
    elif cmd == "comments":
        await bot.say("```\nIf you want to add comments to your procedures to make them easier to understand, simply add lines beginning with the hash (#) character:\n\n# <comments>\n\nAny line beginning with the hash is simply ignored when executing the procedure, so the execution continues at the following line.\n```")
    elif cmd == "expressions":
        await bot.say('```\nSimple expressions:\n\n<number>\n"<text>"\n%<variable_name>%\n%<variable_name>%[<number>]\n%<variable_name>%[<number>+]\n%<variable_name>%["<text>"]\n%<variable_name>%[%<variable_name>%]\n\nComplex expressions:\n\n<simple_expression> [<operator> <expression>]\n(<expression>) [<operator> <expression>]\n<function_name>(<simple_expression>[, <simple_expression>]...)\n\nNote: When multiple operators are used without parentheses, they are not guaranteed to be evaluated in any particular order. C-style escape sequences, such as \\n, can be used in string literals.\n```')
    elif cmd == "operators":
        await bot.say("```\nYou can use the following binary operators in complex expressions:\n\n= - results in true if both sides are equal\n!= - results in true if each side is different\n> - results in true if left side is greater than right side\n>= - results in true if left side is greater or equal to right side\n< - results in true if left side is lower than right side\n<= - results in true if left side is lower or equal to right side\n+ - add two numbers/strings/arrays\n- - subtract second number/string/array from first one\n/ - divide first number by second number\n* - multiply two numbers\nand - true if both sides are true\nor - true if at least one of the sides is true\nin - true if value on the left exists in array/string on the right\nnotin - true if value on the left doesn't exist in array/string on the right\n```")
    elif cmd == "functions":
        await bot.say("```\nThe following functions are currently supported by MadCommands:\n\ngeturl(<url>) loads web url and returns its contents\nurlencode(<array>|<string>) encodes data to be used in url\ndejson(<string>) decodes JSON data to an array\nsplit(<string>, <delimiter>) converts string to an array\njoin(<array>, <delimiter>) converts array to a string\nsize(<array>|<string>) returns array elements count or string length\narray(<value>[, <value>] ...) builds a flat array from supplied parameters\nvarset(<variable>) returns true if <variable> exists\nrandom(<min>, <max>) returns random integer number in the <min>..<max> range\nint(<number>) returns integer part of number by cutting off the fractional part\n\nlowercase(<string>) converts string to lowercase letters\nuppercase(<string>) converts string to uppercase letters\nsubstring(<string>, <start>, <length>) extracts part of a text string\nposition(<array>|<string>, <substring>) returns position of substring in array or string\nreplace(<array>|<string>, <original>, <replacement>) replaces all occurrences of <original> in array or string with <replacement>\n\nonlineplayers([<filter>]) returns array of online player names\nplayerstatus(<playername>) returns array of information about player\nplayerarmor(<playername>) returns array of armor currently worn by player\nplayerinventory(<playername>) returns array of player's survival inventory\nplayerhand(<playername>) returns item held by the player in hand\nplayerbalance(<playername>) returns economy money balance of the player\nplayergroup(<playername>) returns PurePerms group/rank of the player\n\nblockinfo(<level>, <x>, <y>, <z>) returns array of information about world block\nblockcontents(<level>, <x>, <y>, <z>) returns contents of block, such as chest or sign\n\ndialog(<player>, <form_data>) shows dialog to player and returns response\n\nType /cmd help <function> to get detailed help for a specific function.\n```")
    elif cmd == "geturl":
        await bot.say('```\ngeturl(<url>) loads web url and returns its contents as string\n\nIf you know something about web APIs you know how powerful this function can be. if you dont check out the following online resources:\n\nUseful article: Web APIs for non-programmers:\nhttps://schoolofdata.org/2013/11/18/web-apis-for-non-programmers/\n\nGreat testing environment: JSONPlaceholder\nhttps://jsonplaceholder.typicode.com\n\nThe programmableweb.com website has a great directory of web APIs you could utilize. Or simply create your own on your website:\nhttps://www.programmableweb.com/category/all/apis\n\nIn order to avoid lag as much as possible, using the geturl function automatically temporarily switches your procedure execution to async mode if you try to use it in the synchronous mode. It is however still a good idea to ensure that you only use it for web APIs which return their results very fast.\n\nTo avoid waiting for a response forever, MadCommands has two configurable timeout options - geturl-max-connect-time and geturl-max-transfer-time. Type /cmd help config to learn about changing configurable options.\n\nSee also the urlencode and dejson functions as they are very useful when using geturl.\n\nEXAMPLES:\n1 let %myip% = geturl("https://api.ipify.org")\n2 let %users% = dejson(geturl("https://jsonplaceholder.typicode.com/users"))\n```')
    elif cmd == "variables":
        await bot.say("```\nIn addition to defining your own variables, you can use the following pre-defined variables in your commands:\n\n%p% Name of the player running the command\n%x% Player's x coordinate\n%y% Player's y coordinate\n%z% Player's z coordinate\n%yaw% Player's yaw (horizontal look direction)\n%pitch% Player's pitch (vertical look direction)\n%level% Player's level\n%gm% Player's gamemode\n%health% Player's health (0-20)\n%time% Current time in seconds from 16 August 2011 00:00:00\n%args% Array holding all parameters, while parameter 0 being the command itself\n%args%[n] N-th parameter of the command\n%args%[n+] All remaining parameters starting with N-th parameter\n%true% Bollean true\n%false% Bollean false\n```")
    elif cmd == "events":
        await bot.say("```\nThe following events can be set to trigger custom MadCommands procedure.\nProcedure does not have to be registered as command.\nWhen event triggers your procedure it will pass key information about the event to the\nprocedure as parameters.\nSome events can be cancelled using the cancel command if it is used soon enough.\n\nstartup triggers when the server finishes starting up\nshutdown triggers when the server is shutting down (or the plugin is disabled)\nlogin triggers when player joins the server\nleave triggers when player leaves the server\nspawn triggers when player is spawned or respawned\nbed triggers when player enters or leaves a bed (entering bed can be cancelled)\ngm triggers when player switches gamemode (can be cancelled)\neat triggers when player eats food (can be cancelled)\nchat triggers when player writes message in chat (can be cancelled)\ndamage triggers when player or mob gets damage (can be cancelled)\ndeath triggers when player dies\ncheat triggers when player tries to cheat (can be cancelled)\nplace triggers when player places a block (can be cancelled)\nbreak triggers when player breaks a block (can be cancelled)\ntouch triggers when player touches a block (can be cancelled)\nmove triggers when player moves to or from specified area\n\nType /cmd help <event> to get detailed help for a specific event.\n```")
    elif cmd == "startup":
        await bot.say('```\nstartup triggers when the server finishes starting up\n\nThe command procedure you assign to the startup event will not be passed any parameters except for the event name:\n\n%args%[1] event name as string ("startup")\n```')
    elif cmd == "shutdown":
        await bot.say('```\nshutdown triggers when the server is shutting down or the plugin is disabled\n\nThe command procedure you assign to the startup event will not be passed any parameters except for the event name:\n\n%args%[1] event name as string ("shutdown")\n\nKeep in mind you should limit actions you perform in this procedure to an absolute minimum and finish promptly. Asynchronous and scheduled commands are likely to fail.\n```')
    elif cmd == "login":
        await bot.say('```\nlogin triggers when player joins the server\n\nThe command procedure you assign to the login event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("login")\n%args%[2] name of the player joining\n```')
    elif cmd == "leave":
        await bot.say('```\nleave triggers when player leaves the server\n\nThe command procedure you assign to the leave event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("leave")\n%args%[2] name of the player leaving\n\nYou cannot cancel this event.\n```')
    elif cmd == "spawn":
        await bot.say('```\nspawn triggers when player is spawned or respawned\n\nThe command procedure you assign to the spawn event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("spawn")\n%args%[2] name of the spawned player\n%args%[3] name of the level (world) the player has spawned in\n%args%[4] the X coordinate of the spawn point\n%args%[5] the Y coordinate of the spawn point\n%args%[6] the Z coordinate of the spawn point\n\nYou cannot cancel this event.\n```')
    elif cmd == "bed":
        await bot.say('```\nbed triggers when player enters or leaves a bed (entering bed can be cancelled)\n\nThe command procedure you assign to the bed event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("bed")\n%args%[2] name of the spawned player\n%args%[3] either "enter" or "leave"\n%args%[4] name of the level (world) the bed is in\n%args%[5] the X coordinate of the beds position\n%args%[6] the Y coordinate of the beds position\n%args%[7] the Z coordinate of the beds position\n\nIf the player is entering the bed, you can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n\nYou cannot cancel leaving bed.\n```')
    elif cmd == "gm":
        await bot.say('```\ngm triggers when player switches gamemode (can be cancelled)\n\nThe command procedure you assign to the gm event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("gm")\n%args%[2] name of the player whose gamemode is being changed\n%args%[3] the new gamemode requested\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n```')
    elif cmd == "eat":
        await bot.say('```\neat triggers when player eats food (can be cancelled)\n\nThe command procedure you assign to the eat event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("eat")\n%args%[2] name of the player trying to eat\n%args%[3] ID of the item being eaten\n%args%[4] Damage value of the item being eaten\n%args%[5] Name of the item being eaten\n%args%[6] Tags of the item being eaten, if any\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n```')
    elif cmd == "chat":
        await bot.say('```\nchat triggers when player writes message in chat (can be cancelled)\n\nThe command procedure you assign to the chat event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("chat")\n%args%[2] name of the player trying to write in chat\n%args%[3] message the player has written\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n```')
    elif cmd == "damage":
        await bot.say('```\ndamage triggers when player or mob gets damage (can be cancelled)\n\nThe command procedure you assign to the damage event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("damage")\n%args%[2] name of the player getting damage\n%args%[3] name of the damager (whos caused the damage)\n%args%[4] ID of the damage cause\n%args%[5] Name of the damage cause\n%args%[6] Base amount of damage being caused before applying modifiers\n%args%[7] Final damage amount being applied to the player\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n```')
    elif cmd == "death":
        await bot.say('```\ndeath triggers when player dies\n\nThe command procedure you assign to the death event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("death")\n%args%[2] name of the player killed\n%args%[3] name of the damager (whos killed the player)\n%args%[4] ID of the damage cause that killed the player\n%args%[5] Name of the damage cause that killed the player\n\nYou cannot cancel this event.\n```')
    elif cmd == "cheat":
        await bot.say('```\ncheat triggers when player tries to cheat (can be cancelled)\n\nThe command procedure you assign to the cheat event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("cheat")\n%args%[2] name of the player trying to cheat\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n\nNote that not all kinds of cheats can be detected.\n```')
    elif cmd == "place":
        await bot.say('```\nplace triggers when player places a block (can be cancelled)\n\nThe command procedure you assign to the place event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("place")\n%args%[2] name of the player trying to place the block\n%args%[3] name of the level (world) the block is being placed in\n%args%[4] the X coordinate of the position the block is being placed at\n%args%[5] the Y coordinate of the position the block is being placed at\n%args%[6] the Z coordinate of the position the block is being placed at\n%args%[7] ID of the item being placed\n%args%[8] Variant (meta) value of the item being placed\n%args%[9] Name of the item being placed\n%args%[10] Tags of the item being placed, if any\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n```')
    elif cmd == "break":
        await bot.say('```\nbreak triggers when player breaks a block (can be cancelled)\n\nThe command procedure you assign to the break event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("break")\n%args%[2] name of the player trying to break the block\n%args%[3] name of the level (world) the block is being broken in\n%args%[4] the X coordinate of the position of the block being broken\n%args%[5] the Y coordinate of the position of the block being broken\n%args%[6] the Z coordinate of the position of the block being broken\n%args%[7] ID of the tool being used to break the block\n%args%[8] Variant (meta) value of the tool being used to break the block\n%args%[9] Name of the tool being used to break the block\n%args%[10] Tags of the tool being used to break the block, if any\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n```')
    elif cmd == "touch":
        await bot.say('```\ntouch triggers when player touches a block (can be cancelled)\n\nThe command procedure you assign to the touch event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("touch")\n%args%[2] name of the player trying to touch the block\n%args%[3] name of the level (world) the block is being touched in\n%args%[4] the X coordinate of the position of the block being touched\n%args%[5] the Y coordinate of the position of the block being touched\n%args%[6] the Z coordinate of the position of the block being touched\n%args%[7] ID of the tool/item being used to touch the block (if any)\n%args%[8] Variant (meta) value of the tool/item being used to touch the block\n%args%[9] Name of the tool/item being used to touch the block\n%args%[10] Tags of the tool/item being used to touch the block, if any\n\nYou can request to cancel (disallow) this event using the cancel command. Use the cancel command early in the procedure, before you try to use any game commands, the sleep command, or switch to the async mode.\n```')
    elif cmd == "move-event":
        await bot.say('```\nmove triggers when player moves from or to a specified area\n\nTo prevent from running too often, the move event handler is not triggered on every player movement but only in cases when player enters or leaves specific cubic area in a specific level (world).\n\nThe command procedure you assign to the move event will be passed the following parameters you can check by accessing the %args% variable:\n\n%args%[1] event name as string ("move")\n%args%[2] name of the player moving\n%args%[3] direction ("from" or "to")\n%args%[4] area name or "<level>[<x1>,<y1>,<z1>|<x2>,<y2>,<z2>]"\n```')
    elif cmd == "move":
        await bot.say("```\nType -help move-command to get help for the move command, or -help move-event to get help for the move event trigger.\n```")
    elif cmd == "permissions":
        await bot.say("```\nGrant or deny the following permissions to control who can define or use custom commands:\n\ncmd.edit - Create and manage custom defined commands, Default: Op\ncmd.edit.<command_name> - Manage specific command, Default: inherited from cmd.edit\ncmd.run - Execute custom commands without explicit permission defined, Default: Allow\ncmd.run.<command_name> - inherited from cmd.run if not specified\ncmd.<subcommand> - Use specific /cmd subcommand, Default: inherited from cmd.edit\n```")
    elif cmd == "license":
        await bot.say("```\nThis plugin is developed and maintained by madhon, available at madhon@mad-hon.com.\n\nThis plugin is distributed under a commercial license and you are only allowed to use it\nin the way and extent and under conditions explicitly agreed on with madhon in writing.\n```")
    elif cmd == "urlencode":
        await bot.say('```\nurlencode(<array>|<string>) encodes data to be used in url\n\nWhen calling a web URL using the geturl function, you may want to supply some parameters. To use in URL, parameters must be encoded, so that there are no invalid characters in the URL.\n\nFor example "This is $1,000,000 feature"\nbecomes "This+is+%241%2C000%2C000+feature"\n```')
    elif cmd == "dejson":
        await bot.say('```\ndejson(<string>) decodes JSON data to an array\n\nMost RESTful APIS today use JSON as format of the data they return. To let you easily work with JSON formatted results, the dejson function lets you convert any valid JSON to an array.\n\nEXAMPLE:\nIf you have a small phone directory available online at http://myphonedir.xyz/, returning the following JSON data:\n\n{"John" : "123-456-7890", "Frank" : "987-654-3210"}\n\nyou can create a phone lookup command procedure like this:\n\n1 let %directory% = geturl("http://myphonedir.xyz/")\n2 let %name% = %args%[1]\n3 if varset(%directory%[%name%]) then goto 6\n4 message %p% %name% not found in the directory\n5 exit\n6 let %phone% = %directory%[%name%]\n7 message %p% %name%s phone number is %phone%\n```')
    elif cmd == "split":
        await bot.say('```\nsplit(<string>, <delimiter>) converts string to an array\n\nFor example, if you have comma delimited list of players:\n\nlet %players% = "madhon, knedlik, nohdam, knedlok"\n\nYou can convert it to array of player names using:\n\nlet %names% = split(%players%, ", ")\n\nSee also the join function which can join an array back to a string.\n```')
    elif cmd == "join":
        await bot.say('```\njoin(<array>, <delimiter>) converts array to a string\n\nFor example, if you have an array of player names, just as the result from the example in the description of the split function, you can convert it back, but this time to a semicolon delimited list, using this command:\n\nlet %players% = join(%names%, "; ")\n```')
    elif cmd == "size":
        await bot.say('```\nsize(<array>|<string>) returns array elements count or string length\n\nIf you have a string variable %mystring%, this function lets you check its length in the number of characters:\n\nsize(%mystring%)\n\nif you have a variable %myarray% containing an array of values, you can check the number of items in the array:\n\nsize(%myarray%)\n\nYou can then easily loop through the array and perform some operation on each item.\n\nEXAMPLE:\n1 let %online% = onlineplayers()\n2 let %count% = size(%online%)\n3 message %p% There are %count% players online\n```')
    elif cmd == "array":
        await bot.say('```\narray(<value>[, <value>] ...) builds a flat array from supplied parameters\n\nThis function is useful mostly for quickly building arrays from literals.\n\nEXAMPLES:\n1 %day_names% = array("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat")\n2 %prime_numbers% = array(1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29)\n```')
    elif cmd == "varset":
        await bot.say('```\nvarset(<variable>) returns true if <variable> exists\n\nUse this function to check whether a variable or array element is set before using it as parameter for functions and commands to avoid producing errors and unwanted results.\n\nEXAMPLE:\n1 if varset(%args%[1]) then goto 4\n2 message %p% You have not provided any parameter\n3 exit\n4 let %parameter% = %args%[1]\n```')
    elif cmd == "random":
        await bot.say('```\nrandom(<min>, <max>) returns random integer number in the <min>..<max> range\n\nThis can be very important function for building minigames.\n\nEXAMPLE:\n1 let %teams% = array("RED", "BLUE")\n2 let %rnd% = random(0, 1)\n3 let %myteam% = %teams%[%rnd%]\n4 message %p% You have joined the %myteam% team\n```')
    elif cmd == "lowercase":
        await bot.say('```\nlowercase(<string>) converts string to lowercase letters\n\nIts as simple as that.\nYou can use this function on strings you want to compare if you want the comparison to be case insensitive.\n\nEXAMPLE:\nlowercase("Hello World") will return "hello world"\n```')
    elif cmd == "uppercase":
        await bot.say('```\nuppercase(<string>) converts string to uppercase letters\n\nIts as simple as that.\nYou can use this function on strings you want to compare if you want the comparison to be case insensitive.\n\nEXAMPLE:\nuppercase("Hello World") will return "HELLO WORLD"\n```')
    elif cmd == "substring":
        await bot.say('```\nsubstring(<string>, <start>, <length>) extracts part of a text string\n\nIn this function <start> is zero-based index of the first character to extract from the string. So if you pass 0 there, you will be extracting beginning of the string. You can also think of it as number of characters to skip from the beginning of the string.\n\nIf you have a string "Hello World, its me, madhon" and you want to extract just the word "madhon" out of it, you can do it like this:\n\nsubstring("Hello World, its me, madhon", 22, 6)\n\nThis function, however, supporst also special cases. For instance, using negative value for <start> will make it count the cahracters from the end of the string, not from the beginning. So you can extract "madhon" from the same string also this way:\n\nsubstring("Hello World, its me, madhon", -6, 6)\n```')
    elif cmd == "position":
        await bot.say('```\nposition(<array>|<string>, <substring>) returns position of substring in array or string\n\nIf the first parameter is string, this function returns zero-based position of the first occurrence of the substring it finds in the string.\n\nIf the first parameter is an array, it returns index of the first occurrence of array value matching the substring.\n\nIf the substring is not found, this function returns -1.\n\nEXAMPLES:\nposition("Hello world", "world") will return 6\nposition("Hello World", "world") will return -1 because it is case sensitive\nposition(array("Hello", "World"), "World") will return 1\n```')
    elif cmd == "replace":
        await bot.say('```\nreplace(<array>|<string>, <original>, <replacement>) replaces all occurrences of <original> in array or string with <replacement>\n\nIf the first parameter is string, this function simply finds all occurrences of the <original> in it and replaced is with <replacement>.\n\nIf the first parameter is an array, this function goes through all values of the array and performs the action on every one of them.\n\nThis function is case sensitive.\n\nEXAMPLES:\nreplace("Hello madhon", "madhon", "knedlik") will return "Hello knedlik"\nreplace("Hello %p", "%p", %p) when run by knedlik will return "Hello knedlik"\nreplace(array("red onion", "red dwarf", "blue dip"), "red", "cool") will return an array containing these values: ["cool onion", "cool dwarf", "blue dip"]\n```')
    elif cmd == "int":
        await bot.say('```\nint(<number>) returns integer part of number by cutting off the fractional part\n\nFor example, players coordinates are normally returned as precise float numbers, which is sometimes impractical when you only need the block-precision coordinates.\n\nSo you can use the int function to strip out the fractional part and get the integer part of each coordinate.\n\nEXAMPLE:\n1 let %xx% = int(%x%)\n2 let %yy% = int(%y%)\n3 let %zz% = int(%z%)\n4 popup %p% %xx% %yy% %zz%\n```')
    elif cmd == "onlineplayers":
        await bot.say('```\nonlineplayers([<filter>]) returns array of online player names\n\nIf you want a list of all players currently connected to your server, just use the function with no parameters:\n\nonlineplayers()\n\nIf you are lucky to have many players on your server and want to list just those who have "steve" somewhere in their nickname, you can filter the online players by providing a filter string:\n\nonlineplayers("steve")\n```')
    elif cmd == "playerstatus":
        await bot.say('```\nplayerstatus(<playername>) returns array of information about player\n\nThis function returns an associative array with these elements:\n\n["x"] Players x coordinate\n["y"] Players y coordinate\n["z"] Players z coordinate\n["yaw"] Players yaw (horizontal look direction)\n["pitch"] Players pitch (vertical look direction)\n["level"] Players level\n["gm"] Players gamemode\n["health"] Players health (0-20)\n["food"] Players food/hunger (0-20)\n["saturation"] Players saturation (0-14.4)\n["exhaustion"] Players exhaustion (0-4)\n["xplevel"] Players experience level (0-24791)\n["xpprogress"] Players experience progress within current level (0-1.0)\n["online"] True if the player is currently online\n["op"] True if the player is op\n["ip"] IP address from which the player is connected\n```')
    elif cmd == "playerarmor":
        await bot.say('```\nplayerarmor(<playername>) returns array of armor currently worn by player\n\nThis function returns an array of 4 elements:\n\n[0] item used as helmet\n[1] item used as chestplate/tunic\n[2] item used as pants\n[3] item used as boots\n\nEach of these elements is an associative arrays with these elements:\n\n["id"] ID of the item (0 for no armor)\n["damage"] Damage level of the item\n["name"] Name of the item, i.e. "Diamond Helmet"\n["tags"] Tags of the item, if any\n```')
    elif cmd == "playerinventory":
        await bot.say('```\nplayerinventory(<playername>) returns array of players survival inventory\n\nThis function returns an array of items the player has in the survival inventory. Each element of this array is an associative arrays with these elements:\n\n["id"] ID of the item (0 for no armor)\n["variant"] Meta value or damage level of the item\n["count"] Count of the items held in single inventory slot\n["name"] Name of the item\n["tags"] Tags of the item, if any\n```')
    elif cmd == "playerhand":
        await bot.say('```\nplayerhand(<playername>) returns item held by the player in hand\n\nThis function returns an associative array with these elements:\n\n["id"] ID of the item (0 for no armor)\n["variant"] Meta value or damage level of the item\n["count"] Count of the items held in single inventory slot\n["name"] Name of the item\n["tags"] Tags of the item, if any\n["invslot"] ID of the inventory slot the item in hand is from\n```')
    elif cmd == "playerbalance":
        await bot.say('```\nplayerbalance(<playername>) returns economy money balance of the player\n\nThis function returns current economy money balance of the specified player.\nYou can use this function to check whether the player has enough money to pay for using\nyour command before you try to take money from his/her account.\n```')
    elif cmd == "playergroup":
        await bot.say('```\nplayergroup(<playername>) returns PurePerms group/rank of the player\n\nThis function returns name of the group the specifief player has assigned in PurePerms.\nYou can use this function to check whether the player is member of certain group (has certain rank) in order to decide whether/how specific command will work for him/her.\n```')
    elif cmd == "blockinfo":
        await bot.say('```\nblockinfo(<level>, <x>, <y>, <z>) returns array of information about world block\n\nThis function returns an associative array with these elements:\n\n["id"] ID of the item (0 for no armor)\n["variant"] Meta value or damage level of the item\n["name"] Name of the item\n["data"] Any custom data stored with the block\n```')
    elif cmd == "blockcontents":
        await bot.say('```\nblockcontents(<level>, <x>, <y>, <z>) returns contents of block, such as chest or sign\n\nThis function returns an array of items the specified block holds in its inventory.\n\nFor chests each element of this array is an associative arrays with these elements:\n\n["id"] ID of the item (0 for no armor)\n["variant"] Meta value or damage level of the item\n["count"] Count of the items held in single inventory slot\n["name"] Name of the item\n["tags"] Tags of the item, if any\n\nFor item frames, the array contains one element which is an associative array with these elements:\n\n["id"] ID of the item (0 for no armor)\n["variant"] Meta value or damage level of the item\n["count"] Count of the items held in single inventory slot\n["name"] Name of the item\n["tags"] Tags of the item, if any\n["rotation"] Rotation of the item (between 0 and 7)\n["dropchance"] Chance that the will be dropped when breaking the frame (float value between 0 and 1)\n\nFor signs, the array contains exactly four elements, each of which is a string representing one line of text from the sign:\n\n[0] first line of text\n[1] second line of text\n[2] third line of text\n[3] fourth line of text\n```')
    elif cmd == "dialog":
        await bot.say('```\ndialog(<player>, <form_data>) shows dialog to player and returns response\n\nThis function can be used to prompt specific player for some information and get it back as a response.\n\n<form_data> must be an associative array, containing the following elements:\n\n["title"] text string to use as a dialog title\n["type"] must be one of: "modal" | "form" | "custom_form"\n\nDepending on the dialog type, additional values must be provided.\n\nFor "modal" dialog (simple dialog with two buttons):\n\n["content"] text string to display in the dialog as description\n["button1"] name of first button, pressing this will return true\n["button2"] name of second button, pressing this will return false\n\nResult of the "modal" dialog is a boolean value.\n\nFor "form" dialog (simple form with one ore more buttons and optional images):\n\n["content"] text string to display in the dialog as description\n["buttons"] associative array of button definitions:\n["buttons"]["text"] button name\n["buttons"]["image"] array containing image parameters\n["buttons"]["image"]["type"] image type (only "url" supported)\n["buttons"]["image"]["data"] image url\n\nResult of the "form" dialog is either zero-based index of the pressed button, or boolean false if the player has closed the dialog without pressing a button.\n\nFor "custom_form" dialog:\n\n["content"] array of dialog items, each item represented by an array with the following elements:\n\n["content"]["type"] one of "label" | "input" | "dropdown" | "slider" | "step_slider" | "toggle"\n\n["content"]["text"] text to display as label\n["content"]["default"] default string value for "input" item\n["content"]["placeholder"] value placeholder for "input" item\n["content"]["options"] array of values for "dropdown" item\n["content"]["min"] minimum value for "slider" item\n["content"]["max"] maximum value for "slider" item\n["content"]["steps"] array of step names for "step_slider" item\n```')
        await bot.say('```\n["content"]["default"] either %true% or %false% for "toggle" item\n\nResult of the "custom_form" dialog is an array of values entered in individual items, or boolean false if the player has closed the dialog without pressing the Submit button.\n\nFor "dropdown" and "step_slider" items the value returned is zero-based index of the selected option.\n\nCommand procedure execution is paused while waiting for the players response. In the case of the player leaving server without responding to the dialog, execution is resumed and the function returns boolean false.\n```')
    else:
        await bot.say("```\nType -help <topicname> to show more details about:\n\nediting: how to define and edit your custom commands\nusage: how to run your custom commands\ncommands special commands to use in your scripts\nexpressions: how to write expressions and calculations\noperators: list of supported binary operatory\nfunctions: list of supported functions\nvariables: list of special pre-defined variables\nevents: list of supported event names\npermissions: permission nodes you can use\nlicense: license conditions for using this plugin\n```")

@bot.command(pass_context=True)
async def report(ctx, *, args=None):
    if args == None:
        embed = discord.Embed(name="", description="", color=0xff0000)
        embed.add_field(name="Usage", value="-report <report message..>", inline=True)
        await bot.say(embed=embed)
    else:
        me = await bot.get_user_info('352898973578690561')
        await bot.send_message(me, "Report from `{}`: `{}`".format(ctx.message.author, args))
        await bot.say(":white_check_mark: Successfully reported!")

@bot.command(pass_context=True)
async def cmd(ctx, command=None):
    if command == None:
        embed = discord.Embed(name="", description="Here is a list of available commands.", color=0x00FFFF)
        embed.add_field(name="Commands", value="-cmd\n-help\n-tutorial\n-tutadd\n-invite\n-report", inline=True)
        embed.set_footer(text="Type -cmd <command> to get more info about a specific command.", icon_url=embed.Empty)
        await bot.say(embed=embed)
    elif command == "cmd":
        embed = discord.Embed(name="cmd", description="Get a list of available commands", color=0x00FFFF)
        embed.add_field(name="Usage", value="-cmd [command]", inline=True)
        await bot.say(embed=embed)
    elif command == "help":
        embed = discord.Embed(name="help", description="Get help of the topics in MadCommands", color=0x00FFFF)
        embed.add_field(name="Usage", value="-help [topic]", inline=True)
        await bot.say(embed=embed)
    elif command == "tutorial":
        embed = discord.Embed(name="tutorial", description="Get a list of tutorial commands and their codes", color=0x00FFFF)
        embed.add_field(name="Usage", value="-tutorial <list / command_name>", inline=True)
        await bot.say(embed=embed)
    elif command == "report":
        embed = discord.Embed(name="report", description="Report an issue with the bot", color=0x00FFFF)
        embed.add_field(name="Usage", value="-report <report message..>", inline=True)
        await bot.say(embed=embed)
    elif command == "tutadd":
        embed = discord.Embed(name="tutadd", description="Add a command to (-tutorial list)", color=0x00FFFF)
        embed.add_field(name="Usage", value="-tutadd <command info..>", inline=True)
        await bot.say(embed=embed)
    elif command == "invite":
        embed = discord.Embed(name="invite", description="Invite the bot to your server", color=0x00FFFF)
        embed.add_field(name="Usage", value="-invite", inline=True)
        await bot.say(embed=embed)
    elif command == "setprefix":
        embed = discord.Embed(name="setprefix", description="Change the bot prefix", color=0x00FFFF)
        embed.add_field(name="Usage", value="-setprefix <prefix>", inline=True)
        await bot.say(embed=embed)
    else:
        embed = discord.Embed(name="", description="Here is a list of available commands.", color=0x00FFFF)
        embed.add_field(name="Commands", value="-cmd\n-help\n-tutorial\n-tutadd\n-setprefix\n-invite\n-report", inline=True)
        embed.set_footer(text="Type -cmd <command> to get more info about a specific command.", icon_url=embed.Empty)
        await bot.say(embed=embed)

@bot.command(pass_context=True)
async def tutadd(ctx, *, args=None):
    if args == None:
        embed = discord.Embed(name="", description="", color=0xff0000)
        embed.add_field(name="Usage", value="-tutadd <command info..>", inline=True)
        embed.set_footer(text="Please make sure to add the command name, description, usage and code.", icon_url=embed.Empty)
        await bot.say(embed=embed)
    else:
        me = await bot.get_user_info('352898973578690561')
        await bot.send_message(me, "Command from `{}`:\n{}".format(ctx.message.author, args))
        await bot.say(":white_check_mark: Successfully sent the command info to **XMagmaCreeperX#3657**, please wait until **XMagmaCreeperX** read the command info and add it.")

@bot.command(pass_context=True)
async def tutorial(ctx, args=None):
    if args == None:
        embed = discord.Embed(name="", description="", color=0xff0000)
        embed.add_field(name="Usage", value="-tutorial <list / (command_name)>", inline=True)
        await bot.say(embed=embed)
    elif args == "list":
        embed = discord.Embed(name="Tutorials List", description="", color=0x00ffff)
        embed.add_field(name="Page 1", value="- Heal\n- Calculate-Avtivity\n- Vanish\n - Hud\n- Freeze/Unfreeze", inline=True)
        embed.set_footer(text="Type -tutorial list <page> to go to another page // Type -tutorial <command_name> to get the info of the command (usage, description, name, code)", icon_url=embed.Empty)
        await bot.say(embed=embed)
    elif args == "heal":
        await bot.say("**Command Name:** Heal.\n**Command Description:** Heal yourself or another player.\n**Command Usage:** /heal [player]\n**Command Author:** XMagmaCreeperX#3657\n**Command Code:**\n```\ncmd create heal Heal your self or another player\ncmd add heal let %player% = %args%[1]\ncmd add heal if varset(%player%) then goto 6\ncmd add heal treat %p% 20\ncmd add heal message %p% aYou have been healed!\ncmd add heal exit\ncmd add heal if %player% notin onlineplayers() then message %p% c%player% is not online!\ncmd add heal if %player% notin onlineplayers() then exit\ncmd add heal treat %player% 20\ncmd add heal message %p% aHealed %player%!\ncmd add heal exit\n```")
    elif args == "calculate-activity":
        await bot.say("**Command Name:** Calculate-Activity.\n**Command Description:** Calculate how long players have been online.\n**Command Usage:** This command is automatic, you don't manually use it\n**Command Author**: Ammar#7494\n**Command Code:**\n```\ncmd create join Login event | Not for manual use\ncmd add join load %last-join%\ncmd add join let %last-join%[%p%] = %time%\ncmd add join save %last-join%\ncmd unregister join\ncmd trigger login join\n\ncmd create leave Leave event | Not for manual use\ncmd add leave load %last-join%\ncmd add leave %elapsed% = %time% - %last-join%[%p%]\ncmd add leave load %activity%\ncmd add leave if varset(%activity%[%p%]) = %false% then %activity%[%p%] = 0\ncmd add leave %activity%[%p%] = %activity%[%p%] + %elapsed%\ncmd add leave save %activity%\ncmd unregister leave\ncmd trigger leave leave\n```")
    elif args == "vanish":
	    await bot.say('**Command Name:** Vanish.\n**Command Description:** Makes you vanished.\n**Command Usage:** /vanish\n**Command Author:** XMagmaCreeperX#3657\n**Command Code:**\n```\ncmd create vanish\ncmd add vanish let %status% = playerstatus(%p%)\ncmd add vanish let %op% = %status%["op"]\ncmd add vanish if %op% = %false% then message %p% cOnly OPs can use this command!\ncmd add vanish if %op% = %false% then exit\ncmd add vanish load %vanish%\ncmd add vanish if varset(%vanish%[%p%]) = %false% then let %vanish%[%p%] = \"false\"\ncmd add vanish if %vanish%[%p%] = \"true\"  then goto 13\ncmd add vanish ascon /effect %p% invisibility 999999 1 true\ncmd add vanish message %p% You are now vanished!\ncmd add vanish let %vanish%[%p%] = \"true\"\ncmd add vanish save %vanish%\ncmd add vanish exit\ncmd add vanish ascon /effect %p% clear\ncmd add vanish message %p% You are no longer vanished!\ncmd add vanish let %vanish%[%p%] = \"false\"\ncmd add vanish save %vanish%\ncmd add vanish exit\n```')
    elif args == "hud":
	    await bot.say('**Command Name:** Hud.\n**Command Description:** Turn your superbar on/off.\n**Command Usage:** /hud <on|off>\n**Command Author:** ChinaGirlNL#5723\n**Command Code:**\n```\ncmd create hud Turn the hud on|off\ncmd add hud if varset(%args%[1]) = %false% then message %p% Usage: /hud <on|off>\ncmd add hud if varset(%args%[1]) = %false% then exit\ncmd add hud %a% = %args%[1]\ncmd add hud if %a% = \"off\" then goto 100\ncmd add hud if %a% = \"on\" then goto 50\ncmd add hud message %p% Usage: /hud <on|off>\ncmd add hud exit\ncmd edit hud 49 #on\ncmd add hud %hudr%[%p%] = \"on\"\ncmd add hud save %hudr%\ncmd add hud exit\ncmd edit hud 99 #off\ncmd add hud %hudr%[%p%] = \"off\"\ncmd add hud save %hudr%\ncmd add hud popup %p% \ncmd add hud sleep 0.099\ncmd add hud load %hudr%\ncmd add hud if %hudr%[%p%] = \"off\" then goto 102\ncmd add hud exit\n```')
    elif args == "freeze/unfreeze":
        await bot.say('**Command Name:** Freeze/Unfreeze.\n**Command Description:** Freezes a player and unfreezes a frozen player.\n**Command Usage:** /freeze <player> | /unfreeze <player>\n**Command Author:** XMagmaCreeperX#3657\n**Command Code:**\n```\ncmd create freeze Freeze a player\ncmd insert freeze 1 let %player% = %args%[1]\ncmd insert freeze 2 if varset(%player%) then goto 5\ncmd insert freeze 3 message %p% Usage: /freeze <player>\ncmd insert freeze 4 exit\ncmd insert freeze 5 let %online% = onlineplayers()\ncmd insert freeze 6 if %player% in %online% then goto 9\ncmd insert freeze 7 message %p% c%player% is not online, or the name is incorrect.\ncmd insert freeze 8 exit\ncmd insert freeze 9 load %frozen%\ncmd insert freeze 10 if varset(%frozen%[%player%]) then goto 12\ncmd insert freeze 11 let %frozen%[%player%] = \"false\"\ncmd insert freeze 12 if %frozen%[%player%] = \"true\" then goto 27\ncmd insert freeze 13 let %info% = playerstatus(%player%)\ncmd insert freeze 14 let %xx% = %info%["x"]\ncmd insert freeze 15 let %yy% = %info%["y"]\ncmd insert freeze 16 let %zz% = %info%["z"]\ncmd insert freeze 17 let %world% = %info%["level"]\ncmd insert freeze 18 let %frozen%[%player%] = \"true\"\ncmd insert freeze 19 save %frozen%\ncmd insert freeze 20 message %p% a%player% has been frozen!\ncmd insert freeze 21 load %frozen%\ncmd insert freeze 22 # space\ncmd insert freeze 23 move %player% %world% %xx% %yy% %zz%\ncmd insert freeze 24 sleep 0.2\ncmd insert freeze 25 if %frozen%[%player%] = \"true\" then goto 21\ncmd insert freeze 26 exit\ncmd insert freeze 27 message %p% c%player% is already frozen!\ncmd insert freeze 28 exit```')
        await bot.say('```cmd create unfreeze Unfreeze a frozen player\ncmd insert unfreeze 1 let %player% = %args%[1]\ncmd insert unfreeze 2 if varset(%player%) then goto 5\ncmd insert unfreeze 3 message %p% Usage: /unfreeze <player>\ncmd insert unfreeze 4 exit\ncmd insert unfreeze 5 let %online% = onlineplayers()\ncmd insert unfreeze 6 if %player% in %online% then goto 9\ncmd insert unfreeze 7 message %p% c%player% is not online, or the name is incorrect.\ncmd insert unfreeze 8 exit\ncmd insert unfreeze 9 load %frozen%\ncmd insert unfreeze 10 if %frozen%[%player%] = \"true\" then goto 13\ncmd insert unfreeze 11 message %p% c%player% is not frozen!\ncmd insert unfreeze 12 exit\ncmd insert unfreeze 13 let %frozen%[%player%] = \"false\"\ncmd insert unfreeze 14 save %frozen%\ncmd insert unfreeze 15 message %p% a%player% has been unfrozen!\ncmd insert unfreeze 16 exit\n```')
    else:
        embed = discord.Embed(name="", description="", color=0xff0000)
        embed.add_field(name="Usage", value="-tutorial <list / command_name>", inline=True)
        await bot.say(embed=embed)

@bot.command(pass_context=True)
async def invite(ctx):
    embed = discord.Embed(name="", description="", color=0xff0000)
    embed.add_field(name="", value="[Click here](https://discordapp.com/api/oauth2/authorize?client_id=489013863467974660&permissions=8&scope=bot) to invite me to your discord server.", inline=False)
    await bot.say(embed=embed)

bot.run(os.environ['BOT_TOKEN'])
